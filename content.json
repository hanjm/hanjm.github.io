{"meta":{"title":"hello","subtitle":null,"description":"hanjm's blog","author":"hanjm","url":"https://imhanjm.com"},"pages":[],"posts":[{"title":"深入理解GO时间处理(time.Time)","slug":"深入理解golang时间处理(time.Time)","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2017/10/29/深入理解golang时间处理(time.Time)/","link":"","permalink":"https://imhanjm.com/2017/10/29/深入理解golang时间处理(time.Time)/","excerpt":"","text":"1. 前言时间包括时间值和时区, 没有包含时区信息的时间是不完整的、有歧义的. 和外界传递或解析时间数据时, 应当像HTTP协议或unix-timestamp那样, 使用没有时区歧义的格式, 如果使用某些没有包含时区的非标准的时间表示格式(如yyyy-mm-dd HH:MM:SS), 是有隐患的, 因为解析时会使用场景的默认设置, 如系统时区, 数据库默认时区可能引发事故. 确保服务器系统、数据库、应用程序使用统一的时区, 如果因为一些历史原因, 应用程序各自保持着不同时区, 那么编程时要小心检查代码, 知道时间数据在使用不同时区的程序之间交换时的行为. 第三节会详细解释go程序在不同场景下time.Time的行为. 2. Time的数据结构go1.9之前, time.Time的定义为 type Time struct &#123; // sec gives the number of seconds elapsed since // January 1, year 1 00:00:00 UTC. sec int64 // nsec specifies a non-negative nanosecond // offset within the second named by Seconds. // It must be in the range [0, 999999999]. nsec int32 // loc specifies the Location that should be used to // determine the minute, hour, month, day, and year // that correspond to this Time. // The nil location means UTC. // All UTC times are represented with loc==nil, never loc==&amp;utcLoc. loc *Location&#125; sec表示从公元1年1月1日00:00:00UTC到要表示的整数秒数, nsec表示余下的纳秒数, loc表示时区. sec和nsec处理没有歧义的时间值, loc处理偏移量. 因为2017年闰一秒, 国际时钟调整, Go程序两次取time.Now()相减的时间差得到了意料之外的负数, 导致cloudFlare的CDN服务中断, 详见https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/, go1.9在不影响已有应用代码的情况下修改了time.Time的实现. go1.9的time.Time定义为 // A Time represents an instant in time with nanosecond precision.//// Programs using times should typically store and pass them as values,// not pointers. That is, time variables and struct fields should be of// type time.Time, not *time.Time.//// A Time value can be used by multiple goroutines simultaneously except// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and// UnmarshalText are not concurrency-safe.//// Time instants can be compared using the Before, After, and Equal methods.// The Sub method subtracts two instants, producing a Duration.// The Add method adds a Time and a Duration, producing a Time.//// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.// As this time is unlikely to come up in practice, the IsZero method gives// a simple way of detecting a time that has not been initialized explicitly.//// Each Time has associated with it a Location, consulted when computing the// presentation form of the time, such as in the Format, Hour, and Year methods.// The methods Local, UTC, and In return a Time with a specific location.// Changing the location in this way changes only the presentation; it does not// change the instant in time being denoted and therefore does not affect the// computations described in earlier paragraphs.//// Note that the Go == operator compares not just the time instant but also the// Location and the monotonic clock reading. Therefore, Time values should not// be used as map or database keys without first guaranteeing that the// identical Location has been set for all values, which can be achieved// through use of the UTC or Local method, and that the monotonic clock reading// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)// to t == u, since t.Equal uses the most accurate comparison available and// correctly handles the case when only one of its arguments has a monotonic// clock reading.//// In addition to the required “wall clock” reading, a Time may contain an optional// reading of the current process's monotonic clock, to provide additional precision// for comparison or subtraction.// See the “Monotonic Clocks” section in the package documentation for details.//type Time struct &#123; // wall and ext encode the wall time seconds, wall time nanoseconds, // and optional monotonic clock reading in nanoseconds. // // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic), // a 33-bit seconds field, and a 30-bit wall time nanoseconds field. // The nanoseconds field is in the range [0, 999999999]. // If the hasMonotonic bit is 0, then the 33-bit field must be zero // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext. // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit // unsigned wall seconds since Jan 1 year 1885, and ext holds a // signed 64-bit monotonic clock reading, nanoseconds since process start. wall uint64 ext int64 // loc specifies the Location that should be used to // determine the minute, hour, month, day, and year // that correspond to this Time. // The nil location means UTC. // All UTC times are represented with loc==nil, never loc==&amp;utcLoc. loc *Location&#125; 3. time的行为 构造时间-获取现在时间-time.Now(), time.Now()使用本地时间, time.Local即本地时区, 取决于运行的系统环境设置, 优先取”TZ”这个环境变量, 然后取/etc/localtime, 都取不到就用UTC兜底. func Now() Time &#123; sec, nsec := now() return Time&#123;sec + unixToInternal, nsec, Local&#125;&#125; 构造时间-获取某一时区的现在时间-time.Now().In(), Time结构体的In()方法仅设置loc, 不会改变时间值. 特别地, 如果是获取现在的UTC时间, 可以使用Time.Now().UTC().时区不能为nil. time包中只有两个时区变量time.Local和time.UTC. 其他时区变量有两种方法取得, 一个是通过time.LoadLocation函数根据时区名字加载, 时区名字见IANA Time Zone database, LoadLocation首先查找系统zoneinfo, 然后查找$GOROOT/lib/time/zoneinfo.zip.另一个是在知道时区名字和偏移量的情况下直接调用time.FixedZone(&quot;$zonename&quot;, $offsetSecond)构造一个Location对象. // In returns t with the location information set to loc.//// In panics if loc is nil.func (t Time) In(loc *Location) Time &#123; if loc == nil &#123; panic(\"time: missing Location in call to Time.In\") &#125; t.setLoc(loc) return t&#125;// LoadLocation returns the Location with the given name.//// If the name is \"\" or \"UTC\", LoadLocation returns UTC.// If the name is \"Local\", LoadLocation returns Local.//// Otherwise, the name is taken to be a location name corresponding to a file// in the IANA Time Zone database, such as \"America/New_York\".//// The time zone database needed by LoadLocation may not be// present on all systems, especially non-Unix systems.// LoadLocation looks in the directory or uncompressed zip file// named by the ZONEINFO environment variable, if any, then looks in// known installation locations on Unix systems,// and finally looks in $GOROOT/lib/time/zoneinfo.zip.func LoadLocation(name string) (*Location, error) &#123; if name == \"\" || name == \"UTC\" &#123; return UTC, nil &#125; if name == \"Local\" &#123; return Local, nil &#125; if zoneinfo != \"\" &#123; if z, err := loadZoneFile(zoneinfo, name); err == nil &#123; z.name = name return z, nil &#125; &#125; return loadLocation(name)&#125; 构造时间-手动构造时间-time.Date(), 传入年元日时分秒纳秒和时区变量Location构造一个时间. 得到的是指定location的时间. func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time &#123; if loc == nil &#123; panic(\"time: missing Location in call to Date\") &#125;.....&#125; 构造时间-从unix时间戳中构造时间, time.Unix(), 传入秒和纳秒构造. 序列化反序列化时间-文本和JSON, fmt.Sprintf,fmt.SScanf, json.Marshal, json.Unmarshal时的, 使用的时间格式均包含时区信息, 序列化使用RFC3339Nano()”2006-01-02T15:04:05.999999999Z07:00”, 反序列化使用RFC3339()”2006-01-02T15:04:05Z07:00”. 有点奇特, 格式不太一样但兼容. // String returns the time formatted using the format string// \"2006-01-02 15:04:05.999999999 -0700 MST\"func (t Time) String() string &#123; return t.Format(\"2006-01-02 15:04:05.999999999 -0700 MST\")&#125;// MarshalJSON implements the json.Marshaler interface.// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.func (t Time) MarshalJSON() ([]byte, error) &#123; if y := t.Year(); y &lt; 0 || y &gt;= 10000 &#123; // RFC 3339 is clear that years are 4 digits exactly. // See golang.org/issue/4556#c15 for more discussion. return nil, errors.New(\"Time.MarshalJSON: year outside of range [0,9999]\") &#125; b := make([]byte, 0, len(RFC3339Nano)+2) b = append(b, '\"') b = t.AppendFormat(b, RFC3339Nano) b = append(b, '\"') return b, nil&#125;// UnmarshalJSON implements the json.Unmarshaler interface.// The time is expected to be a quoted string in RFC 3339 format.func (t *Time) UnmarshalJSON(data []byte) error &#123; // Ignore null, like in the main JSON package. if string(data) == \"null\" &#123; return nil &#125; // Fractional seconds are handled implicitly by Parse. var err error *t, err = Parse(`\"`+RFC3339+`\"`, string(data)) return err&#125; 序列化反序列化时间-HTTP协议中的date, 统一GMT, 代码位于net/http/server.go:878 // TimeFormat is the time format to use when generating times in HTTP// headers. It is like time.RFC1123 but hard-codes GMT as the time// zone. The time being formatted must be in UTC for Format to// generate the correct format.//// For parsing this time format, see ParseTime.const TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\" 序列化反序列化时间-time.Format(&quot;$layout&quot;), time.Parse(&quot;$layout&quot;,&quot;$value&quot;), time.ParseInLocation(&quot;$layout&quot;,&quot;$value&quot;,&quot;$Location&quot;) time.Format(&quot;$layout&quot;)格式化时间时, 时区会参与计算. 调time.Time的Year()Month()Day()等获取年月日等时时区会参与计算, 得到一个使用偏移量修正过的正确的时间字符串, 若$layout有指定显示时区, 那么时区信息会体现在格式化后的时间字符串中. 如果$layout没有指定显示时区, 那么字符串只有时间没有时区, 时区是隐含的, time.Time对象中的时区. time.Parse(&quot;$layout&quot;,&quot;$value&quot;), 使用time.Local本地时区, 若$layout有指定显示时区, 那么时区信息会体现在格式化后的time.Time对象. 如果$layout没有指定显示时区, 那么使用time.Local本地时区. time.ParseInLocation(&quot;$layout&quot;,&quot;$value&quot;,&quot;$Location&quot;) 使用传参的时区解析时间, 建议用这个, 没有歧义. // Parse parses a formatted string and returns the time value it represents.// The layout defines the format by showing how the reference time,// defined to be// Mon Jan 2 15:04:05 -0700 MST 2006// would be interpreted if it were the value; it serves as an example of// the input format. The same interpretation will then be made to the// input string.//// Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard// and convenient representations of the reference time. For more information// about the formats and the definition of the reference time, see the// documentation for ANSIC and the other constants defined by this package.// Also, the executable example for time.Format demonstrates the working// of the layout string in detail and is a good reference.//// Elements omitted from the value are assumed to be zero or, when// zero is impossible, one, so parsing \"3:04pm\" returns the time// corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is// 0, this time is before the zero Time).// Years must be in the range 0000..9999. The day of the week is checked// for syntax but it is otherwise ignored.//// In the absence of a time zone indicator, Parse returns a time in UTC.//// When parsing a time with a zone offset like -0700, if the offset corresponds// to a time zone used by the current location (Local), then Parse uses that// location and zone in the returned time. Otherwise it records the time as// being in a fabricated location with time fixed at the given zone offset.//// No checking is done that the day of the month is within the month's// valid dates; any one- or two-digit value is accepted. For example// February 31 and even February 99 are valid dates, specifying dates// in March and May. This behavior is consistent with time.Date.//// When parsing a time with a zone abbreviation like MST, if the zone abbreviation// has a defined offset in the current location, then that offset is used.// The zone abbreviation \"UTC\" is recognized as UTC regardless of location.// If the zone abbreviation is unknown, Parse records the time as being// in a fabricated location with the given zone abbreviation and a zero offset.// This choice means that such a time can be parsed and reformatted with the// same layout losslessly, but the exact instant used in the representation will// differ by the actual zone offset. To avoid such problems, prefer time layouts// that use a numeric zone offset, or use ParseInLocation.func Parse(layout, value string) (Time, error) &#123; return parse(layout, value, UTC, Local)&#125;// ParseInLocation is like Parse but differs in two important ways.// First, in the absence of time zone information, Parse interprets a time as UTC;// ParseInLocation interprets the time as in the given location.// Second, when given a zone offset or abbreviation, Parse tries to match it// against the Local location; ParseInLocation uses the given location.func ParseInLocation(layout, value string, loc *Location) (Time, error) &#123; return parse(layout, value, loc, loc)&#125;func parse(layout, value string, defaultLocation, local *Location) (Time, error) &#123;.....&#125; 序列化反序列化时间-go-sql-driver/mysql中的时间处理.MySQL驱动解析时间的前提是连接字符串加了parseTime和loc, 如果parseTime为false, 会把mysql的date类型变成[]byte/string自行处理, parseTime为true才处理时间, loc指定MySQL中存储时间数据的时区, 如果没有指定loc, 用UTC. 序列化和反序列化均使用连接字符串中的设定的loc, SQL语句中的time.Time类型的参数的时区信息如果和loc不同, 则会调用t.In(loc)方法转时区. 解析连接字符串的代码位于parseDSNParams函数https://github.com/go-sql-driver/mysql/blob/master/dsn.go#L467-L490 // Time Locationcase \"loc\": if value, err = url.QueryUnescape(value); err != nil &#123; return &#125; cfg.Loc, err = time.LoadLocation(value) if err != nil &#123; return &#125;// time.Time parsingcase \"parseTime\": var isBool bool cfg.ParseTime, isBool = readBool(value) if !isBool &#123; return errors.New(\"invalid bool value: \" + value) &#125; 解析SQL语句中time.Time类型的参数的代码位于mysqlConn.interpolateParams方法https://github.com/go-sql-driver/mysql/blob/master/connection.go#L230-L273 case time.Time: if v.IsZero() &#123; buf = append(buf, \"'0000-00-00'\"...) &#125; else &#123; v := v.In(mc.cfg.Loc) v = v.Add(time.Nanosecond * 500) // To round under microsecond year := v.Year() year100 := year / 100 year1 := year % 100 month := v.Month() day := v.Day() hour := v.Hour() minute := v.Minute() second := v.Second() micro := v.Nanosecond() / 1000 buf = append(buf, []byte&#123; '\\'', digits10[year100], digits01[year100], digits10[year1], digits01[year1], '-', digits10[month], digits01[month], '-', digits10[day], digits01[day], ' ', digits10[hour], digits01[hour], ':', digits10[minute], digits01[minute], ':', digits10[second], digits01[second], &#125;...) if micro != 0 &#123; micro10000 := micro / 10000 micro100 := micro / 100 % 100 micro1 := micro % 100 buf = append(buf, []byte&#123; '.', digits10[micro10000], digits01[micro10000], digits10[micro100], digits01[micro100], digits10[micro1], digits01[micro1], &#125;...) &#125; buf = append(buf, '\\'') &#125; 从MySQL数据流中解析时间的代码位于textRows.readRow方法https://github.com/go-sql-driver/mysql/blob/master/packets.go#L772-L777, 注意只要MySQL连接字符串设置了parseTime=true, 就会解析时间, 不管你是用string还是time.Time接收的. if !isNull &#123; if !mc.parseTime &#123; continue &#125; else &#123; switch rows.rs.columns[i].fieldType &#123; case fieldTypeTimestamp, fieldTypeDateTime, fieldTypeDate, fieldTypeNewDate: dest[i], err = parseDateTime( string(dest[i].([]byte)), mc.cfg.Loc, ) if err == nil &#123; continue &#125; default: continue &#125; &#125; &#125; 4. time时区处理不当案例 有个服务频繁使用最新汇率, 所以缓存了最新汇率对象, 汇率对象的过期时间设为第二天北京时间零点, 汇率过期则从数据库中去最新汇率, 设置过期时间的代码如下: var startTime string = time.Now().UTC().Add(8 * time.Hour).Format(\"2006-01-02\")tm2, _ := time.Parse(\"2006-01-02\", startTime)lastTime = tm2.Unix() + 24*60*60 这段代码使用了time.Parse, 如果时间格式中没有指定时区, 那么会得到使用本地时区下的第二天零点, 服务器时区设置为UTC0, 于是汇率缓存在UTC零点即北京时间八点才更新. 公共库中有一个GetBjTime()方法, 注释写着将服务器UTC转成北京时间, 代码如下 // 原版func GetBjTime() time.Time &#123;// 将服务器UTC转成北京时间uTime := time.Now().UTC()dur, _ := time.ParseDuration(\"+8h\")return uTime.Add(dur)&#125;// 改func GetBjTime() time.Time &#123;// 将服务器UTC转成北京时间uTime := time.Now()return uTime.In(time.FixedZone(\"CST\", 8*60*60))&#125; 同事用这个方法将得到的time.Time参与计算, 发现多了8个小时. 觉得有问题, 同事和我讨论了之后, 我们得出结论后就大意地直接把原有函数改了, 我们都没有意识到这是个非常危险操作, 只所以危险是因为这个函数已经在很多服务的代码里用着(要稳!不能乱动公共库!!!). 之前用这个函数是因为老Java项目运行在时区为东八区的系统上, 大量代码使用东八区时间, 但数据库MySQL时区设置为UTC, go项目也运行在UTC时区. 也就是说, Java项目在把时区为UTC数据库当做是东八区来用, Java程序往MySQL写东八区的时间字符串, 在sequel软件中看表内容时虽然字符串是一样的, 但其实内部是UTC的时间, go代码的mysql连接字符串中loc选项为空, 就会使用UTC时区去解析数据, 拿到的数据会多八个小时. 例如Java代码往mysql插入一条”2017-10-29 22:00:00”数据本意是东八区2017年10月29日22点, 但在MySQL内部看来, 这是UTC的2017年10月29日22点, 换算成东八区时间为2017年10月30日6点, 如果其它程序解析时认为时间数据是MySQL的UTC时区, 那么会得到一个错误的时间. 所以才会在GO中要往Java代码创建的表写入数据时用time.Now().UTC().Add(time.Hour*8)直接相加八小时使得Java项目行为一致, 拿UTC的数据库存东八区时间. 后面想想, 面对这种数据库中有时区不一致数据的情况, 在没有办法统一UTC时区的情况下, 应当使用MySQL时间字符串而不是time.Time来传递以避免时区隐含转换问题, 写入时参数传string类型的时间字符串, 解析时先拿到时间字符串, 然后自行判断建表时这个字段用的是东八区的时间字符串还是UTC时间字符串进行time.ParseInLocation得到时间对象, MySQL连接字符串的parseTime选项要设置为false. 比如我想在MySQL中存东八区的当前时间, SQL参数用Format后的字符串而不是传time.Time, 原版的time.Now().UTC().Add(time.Hour*8).Format(&quot;2006-01-02 15:04:05&quot;)和修改的time.Now().In(time.FixedZone(&quot;CST&quot;, 8*60*60))的输出将是一样, 但后者是正确的东八区现在时间. 原版的GetBjTime()返回time.Time可能用GetBeijingNowTimeString返回string更能体现本意吧. 5. 时间有关的标准 UTC 协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。中华民国采用CNS 7648的《资料元及交换格式–资讯交换–日期及时间的表示法》（与ISO 8601类似）称之为世界协调时间。中华人民共和国采用ISO 8601:2000的国家标准GB/T 7408-2005《数据元和交换格式 信息交换 日期和时间表示法》中亦称之为协调世界时。协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒[4]，并不遵守夏令时。协调世界时是最接近格林威治标准时间(GMT)的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。 ISO 8601 计算某一天在一年的第几周/循环时间RRlue/会用到此标准 国际标准ISO 8601，是国际标准化组织的日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是第三版“ISO8601:2004”以替代第一版“ISO8601:1988”与第二版“ISO8601:2000”。 UNIX时间 UNIX时间，或称POSIX时间是UNIX或类UNIX系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒[1]。 在多数Unix系统上Unix时间可以通过date +%s指令来检查。 时区 时区列表","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"时间处理","slug":"时间处理","permalink":"https://imhanjm.com/tags/时间处理/"}]},{"title":"Go如何精确计算小数-Decimal研究","slug":"Go如何精确计算小数-decimal研究","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2017/08/27/Go如何精确计算小数-decimal研究/","link":"","permalink":"https://imhanjm.com/2017/08/27/Go如何精确计算小数-decimal研究/","excerpt":"","text":"##1 浮点数为什么不精确先看两个case // case1: 135.90*100 ====// float32var f1 float32 = 135.90fmt.Println(f1 * 100) // output:13589.999// float64var f2 float64 = 135.90fmt.Println(f2 * 100) // output:13590 浮点数在单精度下, 135.9*100即出现了偏差, 双精度下结果正确. // case2: 0.1 add 10 times ===// float32var f3 float32 = 0for i := 0; i &lt; 10; i++ &#123; f3 += 0.1&#125;fmt.Println(f3) //output:1.0000001// float64var f4 float64 = 0for i := 0; i &lt; 10; i++ &#123; f4 += 0.1&#125;fmt.Println(f4) //output:0.9999999999999999 0.1加10次, 这下无论是float32和float64都出现了偏差. 为什么呢, Go和大多数语言一样, 使用标准的IEEE754表示浮点数, 0.1使用二进制表示结果是一个无限循环数, 只能舍入后表示, 累加10次之后就会出现偏差. ##2 数据库是怎么做的MySQL提供了decimal(p,d)/numberlic(p,d)类型的定点数表示法, 由p位数字(不包括符号、小数点)组成, 小数点后面有d位数字, 占p+2个字节, 计算性能会比double/float类型弱一些. ##3 Go代码如何实现Decimal在GitHub搜decimal, star数量比较多的是TiDB里的MyDecimal和ithub.com/shopspring/decimal的实现. shopspring的Decimal实现比较简单, 思路是使用十进制定点数表示法, 有多少位小数就小数点后移多少位, value保存移之后的整数, exp保存小数点后的数位个数, number=value*10^exp, 因为移小数点后的整数可能很大, 所以这里借用标准包里的math/big表示这个大整数. exp使用了int32, 所以这个包最多能表示小数点后有32个十进制数位的情况. Decimal结构体的定义如下 // Decimal represents a fixed-point decimal. It is immutable.// number = value * 10 ^ exptype Decimal struct &#123; value *big.Int // NOTE(vadim): this must be an int32, because we cast it to float64 during // calculations. If exp is 64 bit, we might lose precision. // If we cared about being able to represent every possible decimal, we // could make exp a *big.Int but it would hurt performance and numbers // like that are unrealistic. exp int32&#125; TiDB里的MyDecimal定义位于github.com/pingcap/tidb/util/types/mydecimal.go, 实现比shopspring的Decimal复杂多了, 也更底层(不依赖math/big), 性能也更好(见下面的benchmark). 其思路是:digitsInt保存数字的整数部分数字个数, digitsFrac保存数字的小数部分数字个数, resultFrac保存计算及序列化时保留至小数点后几位, negative标明数字是否为负数, wordBuf是一个定长的int32数组(长度为9), 数字去掉小数点的主体保存在这里, 一个int32有32个bit, 最大值为(2**31-1)2147483647(10个十进制数), 所以一个int32最多能表示9个十进制数位, 因此wordBuf 最多能容纳9*9个十进制数位. // MyDecimal represents a decimal value.type MyDecimal struct &#123; digitsInt int8 // the number of *decimal* digits before the point. digitsFrac int8 // the number of decimal digits after the point. resultFrac int8 // result fraction digits. negative bool // wordBuf is an array of int32 words. // A word is an int32 value can hold 9 digits.(0 &lt;= word &lt; wordBase) wordBuf [maxWordBufLen]int32&#125; 看看这两种decimal类型在文首的两个case下的结果, 同时跑个分. main_test.go package mainimport ( \"testing\" \"github.com/shopspring/decimal\" \"github.com/pingcap/tidb/util/types\" \"log\")var case1String = \"135.90\"var case1Bytes = []byte(case1String)var case2String = \"0\"var case2Bytes = []byte(\"0\")func ShopspringDecimalCase1() decimal.Decimal &#123; dec1, err := decimal.NewFromString(case1String) if err != nil &#123; log.Fatal(err) &#125; dec2 := decimal.NewFromFloat(100) dec3 := dec1.Mul(dec2) return dec3&#125;func TidbDecimalCase1() *types.MyDecimal &#123; dec1 := new(types.MyDecimal) err := dec1.FromString(case1Bytes) if err != nil &#123; log.Fatal(err) &#125; dec2 := new(types.MyDecimal).FromInt(100) dec3 := new(types.MyDecimal) err = types.DecimalMul(dec1, dec2, dec3) if err != nil &#123; log.Fatal(err) &#125; return dec3&#125;func ShopspringDecimalCase2() decimal.Decimal &#123; dec1, err := decimal.NewFromString(case2String) if err != nil &#123; log.Fatal(err) &#125; dec2 := decimal.NewFromFloat(0.1) for i := 0; i &lt; 10; i++ &#123; dec1 = dec1.Add(dec2) &#125; return dec1&#125;func TidbDecimalCase2() *types.MyDecimal &#123; dec1 := new(types.MyDecimal) dec1.FromString(case2Bytes) dec2 := new(types.MyDecimal) dec2.FromFloat64(0.1) for i := 0; i &lt; 10; i++ &#123; types.DecimalAdd(dec1, dec2, dec1) &#125; return dec1&#125;// case1: 135.90*100 ====func BenchmarkShopspringDecimalCase1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; ShopspringDecimalCase1() &#125; b.Log(ShopspringDecimalCase1()) // output: 13590&#125;func BenchmarkTidbDecimalCase1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; TidbDecimalCase1() &#125; b.Log(TidbDecimalCase1()) // output: 13590.00&#125;// case2: 0.1 add 10 times ===func BenchmarkShopspringDecimalCase2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; ShopspringDecimalCase2() &#125; b.Log(ShopspringDecimalCase2()) // output: 1&#125;func BenchmarkTidbDecimalCase2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; TidbDecimalCase2() &#125; b.Log(TidbDecimalCase2()) // output: 1.0&#125; BenchmarkShopspringDecimalCase1-8 2000000 664 ns/op 340 B/op 10 allocs/opBenchmarkTidbDecimalCase1-8 20000000 99.2 ns/op 48 B/op 1 allocs/opBenchmarkShopspringDecimalCase2-8 300000 5210 ns/op 4294 B/op 111 allocs/opBenchmarkTidbDecimalCase2-8 3000000 517 ns/op 83 B/op 3 allocs/op 可见两种实现在上面两个case下表示准确, TiDB的decimal实现的性能高于shopspring的实现, 堆内存分配次数也更少.","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"decimal","slug":"decimal","permalink":"https://imhanjm.com/tags/decimal/"}]},{"title":"DockerContainer下gdb无法正常工作的解决办法","slug":"DockerContainer下gdb无法正常工作的解决办法","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2017/08/20/DockerContainer下gdb无法正常工作的解决办法/","link":"","permalink":"https://imhanjm.com/2017/08/20/DockerContainer下gdb无法正常工作的解决办法/","excerpt":"","text":"昨天想在Mac上使用gdb调试一个Linux下编译的动态链接库, 以正常选项启动一个docker container, 运行gdb却发现如下错误提示. warning: Error disabling address space randomization: Operation not permittedCannot create process: Operation not permittedDuring startup program exited with code 127.(gdb) 在google搜索结果里第6个才找到正确答案, https://www.google.com/search?safe=off&amp;q=docker+gdb+warning%3A+Error+disabling+address+space+randomization%3A+Operation+not+permitted+Cannot+create+process%3A+Operation+not+permitted+During+startup+program+exited+with+code+127&amp;oq=docker+gdb+warning%3A+Error+disabling+address+space+randomization%3A+Operation+not+permitted+Cannot+create+process%3A+Operation+not+permitted+During+startup+program+exited+with+code+127, 原来是docker run中的一个不太常用的选项, docker run –privileged, 加上即可. 于是找官方文档查看此选项的解释, 了解到: 默认docker是以受限模式下运行container, 如不能在container中运行再运行一个docker, 不能访问宿主机上的真实设备, /dev/, gdb无法访问真实的内存设备.&gt; Runtime privilege and Linux capabilities --cap-add: Add Linux capabilities--cap-drop: Drop Linux capabilities--privileged=false: Give extended privileges to this container--device=[]: Allows you to run devices inside the container without the --privileged flag. By default, Docker containers are “unprivileged” and cannot, for example, run a Docker daemon inside a Docker container. This is because by default a container is not allowed to access any devices, but a “privileged” container is given access to all devices (see the documentation on cgroups devices). When the operator executes docker run –privileged, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with –privileged is available on the Docker Blog. If you want to limit access to a specific device or devices you can use the –device flag. It allows you to specify one or more devices that will be accessible within the container. &gt;$ docker run --device=/dev/snd:/dev/snd ...&gt;","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://imhanjm.com/tags/Docker/"}]},{"title":"Go sync.Pool Slice Benchmark","slug":"Go sync.Pool slice benchmark","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2017/07/02/Go sync.Pool slice benchmark/","link":"","permalink":"https://imhanjm.com/2017/07/02/Go sync.Pool slice benchmark/","excerpt":"","text":"纠结于[]struct还是[]*struct直接make([]struct,0) 后append 还是 用sync.Pool make([]struct,100) 写段代码跑个分, 结论是 []*struct的要比[]struct多n次取指针的内存分配, 所有更慢, 如果不用修改结构体元素内的值, 没有必要用指针切片 append[]*struct要比[]struct慢 sync.Pool效果明显 benchmark结果 BenchmarkStructSliceWithoutPool-8 200000 5458 ns/op 16320 B/op 8 allocs/opBenchmarkStructPointerSliceWithoutPool-8 200000 6045 ns/op 8504 B/op 109 allocs/opBenchmarkStructSliceWithPool-8 1000000 1287 ns/op 32 B/op 1 allocs/opBenchmarkStructPointerSliceWithPool-8 300000 4910 ns/op 6498 B/op 102 allocs/op benchmark代码 package mainimport ( \"sync\" \"testing\")var structSlicePool = sync.Pool&#123; New: func() interface&#123;&#125; &#123; return make([]Basic, 100) &#125;,&#125;var structPointerSlicePool = sync.Pool&#123; New: func() interface&#123;&#125; &#123; return make([]*Basic, 100) &#125;,&#125;type Basic struct &#123; Id, N1, N2, N3, N4, N5 int Name string&#125;func BenchmarkStructSliceWithoutPool(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; var list []Basic for j := 0; j &lt; 101; j++ &#123; var data = Basic&#123;Id: j, Name: \"Name\"&#125; list = append(list, data) &#125; &#125;&#125;func BenchmarkStructPointerSliceWithoutPool(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; var list []*Basic for j := 0; j &lt; 101; j++ &#123; var data = Basic&#123;Id: j, Name: \"Name\"&#125; list = append(list, &amp;data) &#125; &#125;&#125;func BenchmarkStructSliceWithPool(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; list := structSlicePool.Get().([]Basic) initLen := len(list) for j := 0; j &lt; 101; j++ &#123; var data = Basic&#123;Id: j, Name: \"Name\"&#125; if j &lt; initLen &#123; list[j] = data &#125; else &#123; list = append(list, data) &#125; &#125; structSlicePool.Put(list) &#125;&#125;func BenchmarkStructPointerSliceWithPool(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; list := structPointerSlicePool.Get().([]*Basic) initLen := len(list) for j := 0; j &lt; 101; j++ &#123; var data = Basic&#123;Id: j, Name: \"Name\"&#125; if j &lt; initLen &#123; list[j] = &amp;data &#125; else &#123; list = append(list, &amp;data) &#125; &#125; structPointerSlicePool.Put(list) &#125;&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"benchmark","slug":"benchmark","permalink":"https://imhanjm.com/tags/benchmark/"}]},{"title":"Go最佳实践","slug":"Go最佳实践","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2017/06/24/Go最佳实践/","link":"","permalink":"https://imhanjm.com/2017/06/24/Go最佳实践/","excerpt":"","text":"来自NSQnsq的官方文档的Dsign中提到一个PPThttps://speakerdeck.com/snakes/nsq-nyc-golang-meetup, 里面有这样一段话总结一下. don’t be afraid of sync packagesync包里有 sync.Mutex(互斥锁,一读一写) sync.RWMutex(读写锁,可以多读一写) sync.Pool(对象池, 合理利用可以减少内存分配, 降低GC压力, 稍后写一篇博客说说) sync.Once(并发控制. 适用于开几个goroutines去执行一个只执行一次的任务, 比如单例模式) sync.Cond(并发控制, cond.Wait()阻塞至其他goroutie运行到cond.Signal()) sync.WaitGroup(并发控制. 通常用法 wg.Add增加任务数量 goroutie完成任务后执行wg.Done,任务数量减1 wg.Wait等待wg任务数量为0) goroutines are cheap not free这句话在其他地方也看过, go func()简单好用, 创建开销也很小, 但也是有开销的. 很多情况下开固定数量worker, 用channel传递数据, 效果会更好.go-apns2中的example是个非常好的例子.https://github.com/sideshow/apns2/blob/master/_example/channel/main.go 注意一个问题, go里面一个goroutine panic了, 会导致进程退出, 所以go func()时第一行带上 go func()&#123; defer func()&#123; if err:=recover(); err!=nil&#123; &#125; &#125;()&#125;() 是安全的做法, worker channel法时类似 package mainimport ( \"fmt\" \"log\" \"time\")func main() &#123; ch := make(chan int, 10) for i := 0; i &lt; 2; i++ &#123; go worker(ch, i) &#125; for i := 0; i &lt; 3; i++ &#123; ch &lt;- i ch &lt;- -1 &#125; time.Sleep(time.Second * 5)&#125;func worker(ch &lt;-chan int, goId int) &#123; defer func(ch &lt;-chan int) &#123; if err := recover(); err != nil &#123; log.Printf(\"worker%d recover error:%s\", goId, err) go worker(ch, goId) &#125; &#125;(ch) log.Printf(\"worker%d running\", goId) for data := range ch &#123; log.Printf(\"worker%d received data:%d\", goId, data) if data == -1 &#123; panic(fmt.Errorf(\"worker%d panic\", goId)) &#125; &#125;&#125; fasthttp之所以快, 其中一个原因就是net/http是来一个连接就创建一个goroutie, 而fasthttp用了池复用了goroutines. watch your allocations (string() is costly, re-user buffers)go里面 []byte和string互转是会发生复制的, 开销明显, 如果代码里频繁互转, 考虑使用bytes.buffer 和 sync.Pool use anonymous structs for arbitrary JSON在写http api时, parse body这种事情, 如果只是纯粹取body里的json数据, 没必要单独定义结构体, 在函数里定义一个匿名结构体就好. var s struct { A int} no built-in per-request HTTP timeouts这是说要注意默认的httpClient没有超时 synchronizing goroutine exit is hard - log each cleanup step in long-running goroutines同步化的goroutine一不小心就没有退出, 如果你写一个长期运行的服务, 用logger记录每一个goroutine的清理退出, 防止goroutine泄露 select skips nil channels select语句是会跳过nil的channels的. 因为在Go里往已经close掉的channel里发送数据是会panic的, 可以利用select语句.附: channel操作导致panic的情况有: 关闭一个nil的channel, 关闭一个已经关闭的channel( j,ok:= &lt;- ch, ok为false时代表ch已经关闭了), 往一个已经关闭的channel里发送数据(从已经关闭的channel里读数据是OK的, 如果这个channel是带缓冲的, 那么可以读到所有数据) 来自GO箴言Python有import this的zen of Python, 想不到Go也有箴言https://speakerdeck.com/ajstarks/go-proverbs 在go里, goroutines之间通信不要用共享内存的方式实现, 应该用channel来实现 并发不是并行 channel是编排, mutexs是串行 interface定义越多的方法, 抽象程度越低. Go提倡用接口组合的方式实现更大的接口 零值, 猜测这里说的是struct{}吧, struct{}是一个不占内存的空结构体, 在用map实现set, channel发送无额外意义的signal时能降低内存分配 提倡gofmt 一点点复制比一点点依赖好. 官方包里有时能见到一些复制的代码, 这是为了不互相依赖 syscall每个平台实现不一样, 要加build tags cgo每个平台的lib不一样, 要加build tags Cgo不是go unsafe包不提供保障 简洁胜过高效 error是值 可以用值的方式去处理错误: 传递, 比较 不用仅检查错误, 要优雅地处理 多花精力设计架构, 模块命名, 写详细的文档 写良好的文档给用户 对于普通错误, 应该用多值返回错误, 而不是手动panic 未知来源 写可重复使用的函数, 接收接口类型, 返回具体类型 Golang Githubhttps://github.com/golang/go/wiki/CodeReviewComments","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"}]},{"title":"GO Logger 日志实践","slug":"Go logger 日志实践","date":"un55fin55","updated":"un00fin00","comments":true,"path":"2017/05/19/Go logger 日志实践/","link":"","permalink":"https://imhanjm.com/2017/05/19/Go logger 日志实践/","excerpt":"","text":"分析一下用过的打印日志的log包 Go标准库自带log, 这个log的func比较少, 没有区分level, 但足够简单, 有prefix功能, 可以设置flag来控制时间格式, caller的文件名和行数, 其它的标准包如 net/http database/sql 等也用了此包. 对自带的log进行包装, 加入level, 颜色. 如ngaut/log, 这个log star数并不多, 还是从最近很火的一个项目pingcap/tidb里看到的, 有点小清新的感觉, 但这个log可能只是为tidb使用的, 缺少自带log的一些方法, 导致没法使用在一些可以定制logger的第三方库如gorm中. 于是我fork了一下https://github.com/hanjm/log, 增加了一些方法, 以便可以给gorm用. 完全自己实现的log, 结构化输出, 通常是key=value或json, 有名的有logrus, zap等. 第一次看到logrus感觉美极了, 于是大量使用, 直到在关注tidb的时候收到带日志的issues邮件, 里面的日志带了caller, 感觉很有用, 于是去搜logrus的issue看有没有这个功能, 搜到了一个issuehttps://github.com/sirupsen/logrus/issues/63, 讨论了三年这个功能还没加上, 只好放弃美丽的logrus, 找到了替代品zap, zap的设计非常好, 定制性强. log是经常调用的代码, 每次调用不可避免地要进行内存分配, 分配次数和每次分配的内存大小将影响性能. 对log内容的处理也是一个涉及到性能的点, 像log.Printf参数是interface{}, logrus的field是map[stirng]interface{}, 打印interface{}只能靠reflect, Go是静态强类型语言, 用反射的开销比较大, 所以zap使用了手动指定类型的方式, 从zap提供的benchmark上开看, 性能提升还是蛮大的, 虽然相比logrus使用起来更麻烦, 但为了性能, 还是值得的. 总结 为了方便进行日志分析, 统一用json行日志, 这样用elk时可以免去定制正则表达式存储到elasticSearch的field中. net/http database/sql 及一些第三方包可能直接使用了标注库的log, 有个trick可以改变所有使用标准包log的行为, 通过log.SetOutput(w io.Writer)来改变位置, w是一个实现了Write(p []byte) (n int, err error)方法的io.Writer即可. runtime.Caller可以得到调用者的pc, 文件名, 文件行数, runtime.FuncForPC(pc).Name()可以得到pc所在的函数名, 对于debug非常有帮助. 但有一定性能开销, 所以方案是: 对于http server的access log, 没有必要使用带caller的日志, 而对于http api具体实现的函数内的log, 有必要记录caller, 而且光有文件名和行数还不够, 毕竟改了代码行数就变了, 而函数名一般不会变, 带上函数名会更直观. GitHub搜了一圈, 好多公司都会定制自己的log, 如tidb的ngaut/log, 七牛的qiniu/log, 饿了么的eleme/log, mailgun的mailgun/log, 是的, 我也造一个小轮子zaplog.zaplog是包装了zap, 带caller func name, 兼容logrus stdlog 的日志输出工具. package zaplogimport ( \"bytes\" \"fmt\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" \"log\" \"runtime\" \"strings\")// CallerEncoder will add caller to log. format is \"filename:lineNum:funcName\", e.g:\"zaplog/zaplog_test.go:15:zaplog.TestNewLogger\"func CallerEncoder(caller zapcore.EntryCaller, enc zapcore.PrimitiveArrayEncoder) &#123; enc.AppendString(strings.Join([]string&#123;caller.TrimmedPath(), runtime.FuncForPC(caller.PC).Name()&#125;, \":\"))&#125;func newLoggerConfig(debugLevel bool) (loggerConfig zap.Config) &#123; loggerConfig = zap.NewProductionConfig() loggerConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder loggerConfig.EncoderConfig.EncodeCaller = CallerEncoder if debugLevel &#123; loggerConfig.Level = zap.NewAtomicLevelAt(zap.DebugLevel) &#125; return&#125;// NewCustomLoggers is a shortcut to get normal logger, noCallerLogger.func NewCustomLoggers(debugLevel bool) (logger, noCallerLogger *zap.Logger) &#123; loggerConfig := newLoggerConfig(debugLevel) logger, err := loggerConfig.Build() if err != nil &#123; panic(err) &#125; loggerConfig.DisableCaller = true noCallerLogger, err = loggerConfig.Build() if err != nil &#123; panic(err) &#125; return&#125;// NewLogger return a normal loggerfunc NewLogger(debugLevel bool) (logger *zap.Logger) &#123; loggerConfig := newLoggerConfig(debugLevel) logger, err := loggerConfig.Build() if err != nil &#123; panic(err) &#125; return&#125;// NewNoCallerLogger return a no caller key value, will be fasterfunc NewNoCallerLogger(debugLevel bool) (noCallerLogger *zap.Logger) &#123; loggerConfig := newLoggerConfig(debugLevel) loggerConfig.DisableCaller = true noCallerLogger, err := loggerConfig.Build() if err != nil &#123; panic(err) &#125; return&#125;// CompatibleLogger is a logger which compatible to logrus/std log/prometheus.// it implements Print() Println() Printf() Dbug() Debugln() Debugf() Info() Infoln() Infof() Warn() Warnln() Warnf()// Error() Errorln() Errorf() Fatal() Fataln() Fatalf() Panic() Panicln() Panicf() With() WithField() WithFields()type CompatibleLogger struct &#123; _log *zap.Logger&#125;// NewCompatibleLogger return CompatibleLogger with caller fieldfunc NewCompatibleLogger(debugLevel bool) *CompatibleLogger &#123; return &amp;CompatibleLogger&#123;NewLogger(debugLevel).WithOptions(zap.AddCallerSkip(1))&#125;&#125;// Print logs a message at level Info on the compatibleLogger.func (l CompatibleLogger) Print(args ...interface&#123;&#125;) &#123; l._log.Info(fmt.Sprint(args...))&#125;// Println logs a message at level Info on the compatibleLogger.func (l CompatibleLogger) Println(args ...interface&#123;&#125;) &#123; l._log.Info(fmt.Sprint(args...))&#125;// Printf logs a message at level Info on the compatibleLogger.func (l CompatibleLogger) Printf(format string, args ...interface&#123;&#125;) &#123; l._log.Info(fmt.Sprintf(format, args...))&#125;// Debug logs a message at level Debug on the compatibleLogger.func (l CompatibleLogger) Debug(args ...interface&#123;&#125;) &#123; l._log.Debug(fmt.Sprint(args...))&#125;// Debugln logs a message at level Debug on the compatibleLogger.func (l CompatibleLogger) Debugln(args ...interface&#123;&#125;) &#123; l._log.Debug(fmt.Sprint(args...))&#125;// Debugf logs a message at level Debug on the compatibleLogger.func (l CompatibleLogger) Debugf(format string, args ...interface&#123;&#125;) &#123; l._log.Debug(fmt.Sprintf(format, args...))&#125;// Info logs a message at level Info on the compatibleLogger.func (l CompatibleLogger) Info(args ...interface&#123;&#125;) &#123; l._log.Info(fmt.Sprint(args...))&#125;// Infoln logs a message at level Info on the compatibleLogger.func (l CompatibleLogger) Infoln(args ...interface&#123;&#125;) &#123; l._log.Info(fmt.Sprint(args...))&#125;// Infof logs a message at level Info on the compatibleLogger.func (l CompatibleLogger) Infof(format string, args ...interface&#123;&#125;) &#123; l._log.Info(fmt.Sprintf(format, args...))&#125;// Warn logs a message at level Warn on the compatibleLogger.func (l CompatibleLogger) Warn(args ...interface&#123;&#125;) &#123; l._log.Warn(fmt.Sprint(args...))&#125;// Warnln logs a message at level Warn on the compatibleLogger.func (l CompatibleLogger) Warnln(args ...interface&#123;&#125;) &#123; l._log.Warn(fmt.Sprint(args...))&#125;// Warnf logs a message at level Warn on the compatibleLogger.func (l CompatibleLogger) Warnf(format string, args ...interface&#123;&#125;) &#123; l._log.Warn(fmt.Sprintf(format, args...))&#125;// Error logs a message at level Error on the compatibleLogger.func (l CompatibleLogger) Error(args ...interface&#123;&#125;) &#123; l._log.Error(fmt.Sprint(args...))&#125;// Errorln logs a message at level Error on the compatibleLogger.func (l CompatibleLogger) Errorln(args ...interface&#123;&#125;) &#123; l._log.Error(fmt.Sprint(args...))&#125;// Errorf logs a message at level Error on the compatibleLogger.func (l CompatibleLogger) Errorf(format string, args ...interface&#123;&#125;) &#123; l._log.Error(fmt.Sprintf(format, args...))&#125;// Fatal logs a message at level Fatal on the compatibleLogger.func (l CompatibleLogger) Fatal(args ...interface&#123;&#125;) &#123; l._log.Fatal(fmt.Sprint(args...))&#125;// Fatalln logs a message at level Fatal on the compatibleLogger.func (l CompatibleLogger) Fatalln(args ...interface&#123;&#125;) &#123; l._log.Fatal(fmt.Sprint(args...))&#125;// Fatalf logs a message at level Fatal on the compatibleLogger.func (l CompatibleLogger) Fatalf(format string, args ...interface&#123;&#125;) &#123; l._log.Fatal(fmt.Sprintf(format, args...))&#125;// Panic logs a message at level Painc on the compatibleLogger.func (l CompatibleLogger) Panic(args ...interface&#123;&#125;) &#123; l._log.Panic(fmt.Sprint(args...))&#125;// Panicln logs a message at level Painc on the compatibleLogger.func (l CompatibleLogger) Panicln(args ...interface&#123;&#125;) &#123; l._log.Panic(fmt.Sprint(args...))&#125;// Panicf logs a message at level Painc on the compatibleLogger.func (l CompatibleLogger) Panicf(format string, args ...interface&#123;&#125;) &#123; l._log.Panic(fmt.Sprintf(format, args...))&#125;// With return a logger with an extra field.func (l *CompatibleLogger) With(key string, value interface&#123;&#125;) *CompatibleLogger &#123; return &amp;CompatibleLogger&#123;l._log.With(zap.Any(key, value))&#125;&#125;// WithField return a logger with an extra field.func (l *CompatibleLogger) WithField(key string, value interface&#123;&#125;) *CompatibleLogger &#123; return &amp;CompatibleLogger&#123;l._log.With(zap.Any(key, value))&#125;&#125;// WithFields return a logger with extra fields.func (l *CompatibleLogger) WithFields(fields map[string]interface&#123;&#125;) *CompatibleLogger &#123; i := 0 var clog *CompatibleLogger for k, v := range fields &#123; if i == 0 &#123; clog = l.WithField(k, v) &#125; else &#123; clog = clog.WithField(k, v) &#125; i++ &#125; return clog&#125;// FormatStdLog set the output of stand package log to zaplogfunc FormatStdLog() &#123; log.SetFlags(log.Llongfile) log.SetOutput(&amp;logWriter&#123;NewNoCallerLogger(false)&#125;)&#125;type logWriter struct &#123; logger *zap.Logger&#125;// Write implement io.Writer, as std log's outputfunc (w logWriter) Write(p []byte) (n int, err error) &#123; i := bytes.Index(p, []byte(\":\")) + 1 j := bytes.Index(p[i:], []byte(\":\")) + 1 + i caller := bytes.TrimRight(p[:j], \":\") // find last index of / i = bytes.LastIndex(caller, []byte(\"/\")) // find penultimate index of / i = bytes.LastIndex(caller[:i], []byte(\"/\")) w.logger.Info(\"stdLog\", zap.ByteString(\"caller\", caller[i+1:]), zap.ByteString(\"log\", bytes.TrimSpace(p[j:]))) return len(p), nil&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"log","slug":"log","permalink":"https://imhanjm.com/tags/log/"}]},{"title":"Linux Cli下酷工具收集(持续)","slug":"Linux cli下酷工具收集(持续)","date":"un66fin66","updated":"un55fin55","comments":true,"path":"2017/05/06/Linux cli下酷工具收集(持续)/","link":"","permalink":"https://imhanjm.com/2017/05/06/Linux cli下酷工具收集(持续)/","excerpt":"","text":"mycli. ipython之于Python, mycli之于mysql. 当然还有pgcli. Python写的工具. Github地址:https://github.com/dbcli/mycli youtube-dl. youtube下载器, 能直接下载youtube视频列表. Python写的工具. oh-my-zsh的z命令. 手动输入一个很长的路径名不停地tab很麻烦, 配置了oh-my-zsh的话可以启用z命令(edit: ~/.zshrc line: plugins=(git python z tmux)), z 文件夹名 就可以跳转到常用目录中最符合输入文件夹名的文件夹中, 非常方便, GitHub地址https://github.com/robbyrussell/oh-my-zsh privoxy. brew pip npm install、docker pull总是慢如蜗牛? privoxy能将shadowsocks的socks代理(127.0.0.1:1080)转换为http/https代理, 有个奇特的地方是把它把文档写在配置文件的注释里, config文件有2271行, 初让人以为配置起来会巨复杂, 实际上基本的功能两行配置即可. listen-address配置为0.0.0.0:8118, 局域网内其他设备也可以走此代理:8118. 官网https://www.privoxy.org/ listen-address 0.0.0.0:8118forward-socks5 / localhost:1080 . 然后在.zshrc或.bashrc中加入一下命令就可以通过proxy dproxy来切换是否在本终端下使用代理了. function proxy()&#123; export http_proxy=http://127.0.0.1:8118 export https_proxy=https://127.0.0.1:8118&#125;function dproxy()&#123; unset http_proxy unset https_proxy&#125; kcptun. bandwagon上的shadowsocks越来越慢, 不用kcptun加速没法正常使用, 只能不太厚道地超量发包了. GitHub地址https://github.com/xtaci/kcptun","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://imhanjm.com/tags/Linux/"},{"name":"Cool tools","slug":"Cool-tools","permalink":"https://imhanjm.com/tags/Cool-tools/"}]},{"title":"MacOS下酷工具收集(持续)","slug":"MacOS下酷工具收集(持续)","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2017/05/06/MacOS下酷工具收集(持续)/","link":"","permalink":"https://imhanjm.com/2017/05/06/MacOS下酷工具收集(持续)/","excerpt":"","text":"LaunchRocket. 系统偏好设置中的用户与群组可以添加登录项脚本, 但对于需要root权限启动的应用无解, 脚本会卡在输入密码. LaunchRocket能优雅解决.(当然, 还有一种魔法方法: 用docker加--restart always的container或docker swarm service 跑, docker启动时会自动启动这些container/service) GitHub地址https://github.com/jimbojsb/launchrocket Snip. Windows下有Winsnap、FastStone、Snipaste等此等优秀的截图软件, 相比之下, Mac上的截图软件要逊色不少. Winsnap有个很方便的特性是截图可以默认复制到剪切板, 很容易粘贴到其他软件去, Mac上snip也有这个特性, snip是一款腾讯开发的截图软件, 官网http://snip.qq.com/ Macdown. 好用优雅免费的Markdown书写工具. GitHub地址https://github.com/MacDownApp/macdown Homebrew. yum/dnf之于centOS, apt之于Ubuntu, pacman之于ArchLinux, brew之于macOS, brew install简直不能太爽. 官网https://brew.sh/ Homebrew-Cask. brew install不能安装chrome Macdown这样的GUI app, Homebrew-Cask扩展了brew, GitHub地址https://github.com/caskroom/homebrew-cask privoxy. brew pip npm install、docker pull总是慢如蜗牛? privoxy能将shadowsocks的socks代理(127.0.0.1:1080)转换为http/https代理, 有个奇特的地方是把它把文档写在配置文件的注释里, config文件有2271行, 初让人以为配置起来会巨复杂, 实际上基本的功能两行配置即可. listen-address配置为0.0.0.0:8118, 局域网内其他设备也可以走此代理:8118. 官网https://www.privoxy.org/ listen-address 0.0.0.0:8118forward-socks5 / localhost:1080 . 然后在.zshrc或.bashrc中加入一下命令就可以通过proxy dproxy来切换是否在本终端下使用代理了. function proxy()&#123; export http_proxy=http://127.0.0.1:8118 export https_proxy=https://127.0.0.1:8118 export HTTP_PROXY=http://127.0.0.1:8118 export HTTPS_PROXY=https://127.0.0.1:8118&#125;function dproxy()&#123; unset http_proxy unset https_proxy unset HTTP_PROXY unset HTTPS_PROXY&#125; kcptun. bandwagon上的shadowsocks越来越慢, 不用kcptun加速没法正常使用, 只能不太厚道地超量发包了. GitHub地址https://github.com/xtaci/kcptun oh-my-zsh的z命令. 手动输入一个很长的路径名不停地tab很麻烦, 配置了oh-my-zsh的话可以启用z命令(edit: ~/.zshrc line: plugins=(git python z tmux)), z 文件夹名 就可以跳转到常用目录中最符合输入文件夹名的文件夹中, 非常方便, GitHub地址https://github.com/robbyrussell/oh-my-zsh aria2. 非常厉害的下载器, brew install aria2即可. GitHub地址:https://github.com/aria2/aria2 GUI Client:https://github.com/yangshun1029/aria2gui BaiduExporter. 百度网盘文件导出到aria2下载, GitHub地址https://github.com/acgotaku/BaiduExporter Chrome插件加白描述文件. 有时需要安装一些在商店下架了的扩展, 比如BaiduExporter, 在扩展页面安装后重启chrome会提示此扩展程序并非来自chrome商店,启用开关灰色无法启用, 可以下载此描述文件将特定扩展id加入白名单. https://hencolle.com/2016/10/16/baidu_exporter/ 坚果云.同步配置文件,pdf书非常方便. Monaco字体. 非常舒服的等宽代码字体 https://github.com/hanjm/codeFont","categories":[],"tags":[{"name":"Cool tools","slug":"Cool-tools","permalink":"https://imhanjm.com/tags/Cool-tools/"},{"name":"Macos","slug":"Macos","permalink":"https://imhanjm.com/tags/Macos/"}]},{"title":"知名公司架构资料整理(持续)","slug":"知名公司后端架构学习(持续)","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2017/05/04/知名公司后端架构学习(持续)/","link":"","permalink":"https://imhanjm.com/2017/05/04/知名公司后端架构学习(持续)/","excerpt":"","text":"1.知乎主要语言栈: Python Java演讲:http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution 2.饿了么主要语言栈: Python Java Go演讲: 2017 gopher上海meetup开源项目: Python: thrift-py RPC轮子 3.Bilibili开源项目: goim 4. Teambition主要语言栈: node.js Go 演讲: 2017 gopher上海meetup 开源项目: Go: Gear HTTP框架 5. Klook主要语言栈: Go 6. PingCAP主要语言栈: GO 开源项目: Go: TiDB 数据库 Go: log 日志工具","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"https://imhanjm.com/tags/架构/"}]},{"title":"Mysql 连接池问题","slug":"mysql连接池问题","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2017/04/26/mysql连接池问题/","link":"","permalink":"https://imhanjm.com/2017/04/26/mysql连接池问题/","excerpt":"","text":"最近应用日志里发现了mysql偶尔会出现问题 [mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56346-&gt;127.0.0.1:3306: write: broken pipe[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56346-&gt;127.0.0.1:3306: write: broken pipe[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56350-&gt;127.0.0.1:3306: write: broken pipe[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56350-&gt;127.0.0.1:3306: write: broken pipe 找GitHub issues, 提到了和mysql的wait_timeout变量有关系, https://github.com/go-sql-driver/mysql/issues/446, 于是找MySQL文档https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#idm140549060476496. 相关说明如下:The number of seconds the server waits for activity on a noninteractive connection before closing it.On thread startup, the session wait_timeout value is initialized from the global wait_timeout value or from the global interactive_timeout value, depending on the type of client (as defined by the CLIENT_INTERACTIVE connect option to mysql_real_connect()). See also interactive_timeout. 默认是28800s, 8小时.mysql&gt; show variables like &apos;%wait_timeout%&apos;; +--------------------------+----------+| Variable_name | Value |+--------------------------+----------+| innodb_lock_wait_timeout | 50 || lock_wait_timeout | 31536000 || wait_timeout | 28800 |+--------------------------+----------+3 rows in set (0.00 sec) 解决办法:db.SetConnMaxLifetime(time.Hour*7)","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://imhanjm.com/tags/mysql/"},{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"连接池","slug":"连接池","permalink":"https://imhanjm.com/tags/连接池/"}]},{"title":"Go strings.TrimLeft() strings.TrimPrefix().md","slug":"Go-strings.TrimLeft-strings.TrimPrefix","date":"un11fin11","updated":"un66fin66","comments":true,"path":"2017/04/24/Go-strings.TrimLeft-strings.TrimPrefix/","link":"","permalink":"https://imhanjm.com/2017/04/24/Go-strings.TrimLeft-strings.TrimPrefix/","excerpt":"","text":"今天在调试时, 有个函数的返回的结果很奇怪, 和预期的输入差了一个字符, 而review代码时却没发现什么问题, 后面各种加logger.Debugf()才发现是strings.TrimLeft()这个函数表现得和自己的预期不一致, 从函数名上看这个是删除字符串左边的字符串, 但是传入一个带:的字符串去调用,发现:后面的字符也被Trim了, 于是去Github issues上搜了下这个问题https://github.com/golang/go/issues/19371, 有人也感觉奇怪也反馈过, 解释是 The second argument to Trim is a set of code points, not a prefix/suffix. , 于是去翻了下文档, 确实是这样的. TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed. 问题复现代码(go 1.8) https://play.golang.org/p/YtmVQIf2_i: package mainimport ( \"fmt\" \"strings\")func main() &#123; str := \"friends:d15fc7bb-1e67-11e7-b8a5-00163e008796\" prefix1 := \"friends:\" prefix2 := \"friends\" fmt.Printf(\"%v\\n\", strings.TrimLeft(str, prefix1)) fmt.Printf(\"%v\\n\", strings.TrimPrefix(str, prefix1)) fmt.Printf(\"%v\\n\", strings.TrimLeft(str, prefix2)) fmt.Printf(\"%v\\n\", strings.TrimPrefix(str, prefix2))&#125; output: 15fc7bb-1e67-11e7-b8a5-00163e008796d15fc7bb-1e67-11e7-b8a5-00163e008796:d15fc7bb-1e67-11e7-b8a5-00163e008796:d15fc7bb-1e67-11e7-b8a5-00163e008796","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"}]},{"title":"深入理解Go Runtime","slug":"深入理解Go runtime","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2017/04/23/深入理解Go runtime/","link":"","permalink":"https://imhanjm.com/2017/04/23/深入理解Go runtime/","excerpt":"","text":"深入理解Goroutines调度 GO SCHEDULER: MS, PS &amp; GS 鸟窝的译文:http://colobu.com/2017/05/04/go-scheduler/ Golang调度器源码分析 http://morsmachine.dk/go-scheduler https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit http://www.sizeofvoid.net/goroutine-under-the-hood/","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"}]},{"title":"Nginx HTTP/2 编译安装","slug":"Nginx HTTP2编译安装","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2017/04/20/Nginx HTTP2编译安装/","link":"","permalink":"https://imhanjm.com/2017/04/20/Nginx HTTP2编译安装/","excerpt":"","text":"yum apt等包管理系统安装的软件有时候比较旧, 导致一些莫名其妙的问题. 最近在给Nginx加HTTP/2模块中, 编译时加上了--with-http_v2_module参数, 但Chrome请求发现还是不是http2, 后面发现是OpenSSL版本太低. 踩过这一坑后, 感觉Linux下部分软件最好还是自己编译安装比较妥, 如果编译过程出错, 搜下错误信息, 一般是基础依赖没有安装, 很好解决. 官方的源码编译指南https://nginx.org/en/docs/configure.htmlhttps://nginx.org/en/docs/http/ngx_http_v2_module.html (这里写了需要OpenSSL1.0.2以上版本), 很多选项都有合适的默认值, 比如–prefix=/usr/local/nginx, 所以只需要指定自己需要的字段 --user=www-data // 习惯将web相关的服务以www-data用户运行, 如没有此用户可以创建一个也可不加此项按默认nobody用户--group=www-data--with-http_v2_module // 默认选项不带http2--with-http_ssl_module // 默认选项不带ssl, 上http2必须要上ssl的--with-stream // https://nginx.org/en/docs/stream/ngx_stream_core_module.html--with-openssl // 指定OpenSSL--with-pcre=./pcre-8.40 // 需要(version 4.4 — 8.40)的pcre,注意Nginx不支持pcre2--with-pcre-jit // 打开pcre JIT支持--with-zlib=./zlib-1.2.11 // 需要(version 1.1.3 — 1.2.11)的zlib以支持gzip 1.官网下载Nginx包 cd /usr/localwget https://nginx.org/download/nginx-1.12.0.tar.gztar -zxf nginx-1.12.0.tar.gzcd nginx-1.12.0 2.[官网下载OpenSSL 1.0.2以上版本].https://github.com/openssl/openssl/releases cd nginx-1.12.0wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_0e.tar.gztar -zxf OpenSSL_1_1_0e.tar.gz 2.官网下载pcre (version 1.1.3 — 1.2.11) 注意Nginx不支持pcre2,下载pcre最新版即可. 解压到Nginx解压的目录 cd nginx-1.12.0wget https://ftp.pcre.org/pub/pcre/pcre-8.40.tar.gztar -zxf pcre-8.40.tar.gz 4.官网下载zlib(version 1.1.3 — 1.2.11) cd nginx-1.12.0wget http://zlib.net/zlib-1.2.11.tar.gztar -zxf zlib-1.2.11.tar.gz 5.编译并安装 ./configure \\--user=www-data \\--group=www-data \\--with-http_v2_module \\--with-http_ssl_module \\--with-stream \\--with-openssl=./openssl-OpenSSL_1_1_0e \\--with-pcre=./pcre-8.40 --with-pcre-jit \\--with-zlib=./zlib-1.2.11make &amp;&amp; make install 6.为了方便操作,软链/usr/local/nginx/sbin/nginx到/usr/local/bin ln -s /usr/local/nginx/sbin/nginx /usr/local/bin","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://imhanjm.com/tags/Nginx/"},{"name":"HTTP","slug":"HTTP","permalink":"https://imhanjm.com/tags/HTTP/"}]},{"title":"Python(Tornado Tornado+uvloop Tornado+uvloop2 Flask Sanic Django) Go(http Httprouter Fasthttp) RPS性能对比","slug":"Python(Tornado Tornado+uvloop tornado+uvloop2 Flask Sanic Django) Go(http httprouter fasthttp) QPS性能对比","date":"un22fin22","updated":"un33fin33","comments":true,"path":"2017/03/21/Python(Tornado Tornado+uvloop tornado+uvloop2 Flask Sanic Django) Go(http httprouter fasthttp) QPS性能对比/","link":"","permalink":"https://imhanjm.com/2017/03/21/Python(Tornado Tornado+uvloop tornado+uvloop2 Flask Sanic Django) Go(http httprouter fasthttp) QPS性能对比/","excerpt":"","text":"在v2ex上发现了一个Python的新web框架, Sanic, 基于uvloop, 其在GitHub上的性能数据十分耀眼, 于是想跟其他用过的web框架对比一下性能, 跑个分嘛. 测试环境:Python:3.6.0 Go:1.8.0 测试脚本:app用tmux启动, 然后使用Apache bench测试, n=1000, c=100, 每个app测5次 for session in test_tornado test_tornadouv test_tornadouv2 test_flask test_sanicdotmux kill-session -t $session &gt; /dev/null 2&gt;&amp;1sleep 1tmux new -s $session -d \"/root/.pyenv/versions/3.6.0/bin/python $session.py\"done# djangotmux kill-session -t test_djangosleep 1tmux new -s test_django -d \"/root/.pyenv/versions/3.6.0/bin/python test_django/manage.py runserver 127.0.0.1:8893\"for session in test_go_http test_go_httprouter test_go_fasthttpdotmux kill-session -t $sessionsleep 1tmux new -s $session -d \"go run $session.go\"donefor ((i=0;i&lt;5;i++))doecho $iab -n 1000 -c 100 http://127.0.0.1:8888/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"tornado-epoll :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8889/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"tornado-uvloop :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8890/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"tornado-uvloop2:%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8891/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"flask :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8892/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"sanic :%s\\n\",$0&#125;'ab -n 1000 -c 10 http://127.0.0.1:8893/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"django :%s\\n\",$0&#125;' # django自带的wsgi server 无法处理concurrent 100ab -n 1000 -c 100 http://127.0.0.1:8894/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"go_http :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8895/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"go_httprouter :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8896/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"go_fasthttp :%s\\n\",$0&#125;'done 测试结果:本机 i5-6600k@3.5GHZ 四核16GB 0tornado-epoll :Requests per second: 1714.60 [#/sec] (mean)tornado-uvloop :Requests per second: 1988.30 [#/sec] (mean)tornado-uvloop2:Requests per second: 1977.77 [#/sec] (mean)flask :Requests per second: 2167.29 [#/sec] (mean)sanic :Requests per second: 14221.72 [#/sec] (mean)django :Requests per second: 1157.64 [#/sec] (mean)go_http :Requests per second: 13847.92 [#/sec] (mean)go_httprouter :Requests per second: 14595.34 [#/sec] (mean)go_fasthttp :Requests per second: 12730.74 [#/sec] (mean)1tornado-epoll :Requests per second: 2011.02 [#/sec] (mean)tornado-uvloop :Requests per second: 1788.50 [#/sec] (mean)tornado-uvloop2:Requests per second: 1980.40 [#/sec] (mean)flask :Requests per second: 2237.84 [#/sec] (mean)sanic :Requests per second: 13614.70 [#/sec] (mean)django :Requests per second: 1145.03 [#/sec] (mean)go_http :Requests per second: 13811.01 [#/sec] (mean)go_httprouter :Requests per second: 13441.94 [#/sec] (mean)go_fasthttp :Requests per second: 12619.25 [#/sec] (mean)2tornado-epoll :Requests per second: 2056.31 [#/sec] (mean)tornado-uvloop :Requests per second: 1831.49 [#/sec] (mean)tornado-uvloop2:Requests per second: 2015.39 [#/sec] (mean)flask :Requests per second: 2124.87 [#/sec] (mean)sanic :Requests per second: 12485.80 [#/sec] (mean)django :Requests per second: 1160.55 [#/sec] (mean)go_http :Requests per second: 14014.43 [#/sec] (mean)go_httprouter :Requests per second: 13949.34 [#/sec] (mean)go_fasthttp :Requests per second: 12419.12 [#/sec] (mean)3tornado-epoll :Requests per second: 2017.32 [#/sec] (mean)tornado-uvloop :Requests per second: 1731.04 [#/sec] (mean)tornado-uvloop2:Requests per second: 2014.46 [#/sec] (mean)flask :Requests per second: 2100.02 [#/sec] (mean)sanic :Requests per second: 12459.04 [#/sec] (mean)django :Requests per second: 1164.06 [#/sec] (mean)go_http :Requests per second: 13239.77 [#/sec] (mean)go_httprouter :Requests per second: 14127.49 [#/sec] (mean)go_fasthttp :Requests per second: 12824.46 [#/sec] (mean)4tornado-epoll :Requests per second: 1810.77 [#/sec] (mean)tornado-uvloop :Requests per second: 1975.12 [#/sec] (mean)tornado-uvloop2:Requests per second: 1962.81 [#/sec] (mean)flask :Requests per second: 2234.08 [#/sec] (mean)sanic :Requests per second: 13881.95 [#/sec] (mean)django :Requests per second: 1154.90 [#/sec] (mean)go_http :Requests per second: 14399.47 [#/sec] (mean)go_httprouter :Requests per second: 13688.69 [#/sec] (mean)go_fasthttp :Requests per second: 12672.99 [#/sec] (mean) 阿里云ECS 双核8GB 0tornado-epoll :Requests per second: 542.60 [#/sec] (mean)tornado-uvloop :Requests per second: 930.95 [#/sec] (mean)tornado-uvloop2:Requests per second: 811.54 [#/sec] (mean)flask :Requests per second: 897.00 [#/sec] (mean)sanic :Requests per second: 5681.50 [#/sec] (mean)django :Requests per second: 447.41 [#/sec] (mean)go_http :Requests per second: 8551.98 [#/sec] (mean)go_httprouter :Requests per second: 9655.31 [#/sec] (mean)go_fasthttp :Requests per second: 11469.21 [#/sec] (mean)1tornado-epoll :Requests per second: 969.97 [#/sec] (mean)tornado-uvloop :Requests per second: 970.14 [#/sec] (mean)tornado-uvloop2:Requests per second: 990.24 [#/sec] (mean)flask :Requests per second: 900.50 [#/sec] (mean)sanic :Requests per second: 5789.89 [#/sec] (mean)django :Requests per second: 435.28 [#/sec] (mean)go_http :Requests per second: 8076.63 [#/sec] (mean)go_httprouter :Requests per second: 9340.99 [#/sec] (mean)go_fasthttp :Requests per second: 6024.82 [#/sec] (mean)2tornado-epoll :Requests per second: 946.98 [#/sec] (mean)tornado-uvloop :Requests per second: 975.64 [#/sec] (mean)tornado-uvloop2:Requests per second: 955.25 [#/sec] (mean)flask :Requests per second: 1021.28 [#/sec] (mean)sanic :Requests per second: 6361.36 [#/sec] (mean)django :Requests per second: 440.23 [#/sec] (mean)go_http :Requests per second: 7601.67 [#/sec] (mean)go_httprouter :Requests per second: 8123.21 [#/sec] (mean)go_fasthttp :Requests per second: 8500.00 [#/sec] (mean)3tornado-epoll :Requests per second: 944.39 [#/sec] (mean)tornado-uvloop :Requests per second: 921.12 [#/sec] (mean)tornado-uvloop2:Requests per second: 980.30 [#/sec] (mean)flask :Requests per second: 946.53 [#/sec] (mean)sanic :Requests per second: 5686.99 [#/sec] (mean)django :Requests per second: 498.31 [#/sec] (mean)go_http :Requests per second: 6297.78 [#/sec] (mean)go_httprouter :Requests per second: 8078.91 [#/sec] (mean)go_fasthttp :Requests per second: 6523.84 [#/sec] (mean)4tornado-epoll :Requests per second: 953.86 [#/sec] (mean)tornado-uvloop :Requests per second: 983.97 [#/sec] (mean)tornado-uvloop2:Requests per second: 955.04 [#/sec] (mean)flask :Requests per second: 994.77 [#/sec] (mean)sanic :Requests per second: 6877.11 [#/sec] (mean)django :Requests per second: 510.76 [#/sec] (mean)go_http :Requests per second: 8243.14 [#/sec] (mean)go_httprouter :Requests per second: 7055.97 [#/sec] (mean)go_fasthttp :Requests per second: 6183.83 [#/sec] (mean) ###结论: Sanic确实叼, 拉出Flask一大截. 由于这个测试只是简单返回”Hello, world”, Tornado的优势要在使用了aio,AsyncHTTPClient的时候才能发挥出来. 如果拿tornado当纯同步使用的话, 性能会比flask弱一点点. Django自带的wsgi server无法完成此任务. fasthttp表现的很奇怪, 可能是handler太简单的情况下sync/pool的代价超过了gc的影响, httprouter比http快一点. ###测试代码: 1.test_tornado.py Tornado 4.4.2 import tornado.ioloopimport tornado.webclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\")def make_app(): return tornado.web.Application([ (r\"/\", MainHandler), ])if __name__ == \"__main__\": app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() 2.test_tornadouv.py Tornado+uvloop(pip install tornadouvloop) import tornado.ioloopimport tornado.webfrom tornadouvloop import TornadoUvloopclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\")def make_app(): return tornado.web.Application([ (r\"/\", MainHandler), ])if __name__ == \"__main__\": app = make_app() app.listen(8889) tornado.ioloop.IOLoop.configure(TornadoUvloop) tornado.ioloop.IOLoop.current().start() 3.test_tornadouv2.py Tornado+uvloop2(pip install tornaduv) import tornado.ioloopimport tornado.webfrom tornaduv import UVLoopclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\")def make_app(): return tornado.web.Application([ (r\"/\", MainHandler), ])if __name__ == \"__main__\": app = make_app() app.listen(8890) tornado.ioloop.IOLoop.configure(UVLoop) tornado.ioloop.IOLoop.current().start() 4.test_flask.py Flask 0.12 from flask import Flaskapp = Flask(__name__)@app.route(\"/\")def hello(): return \"Hello, world\"if __name__ == \"__main__\": app.run(port=8891) 5.test_sanic.py Sanic 0.4.1 from sanic import Sanicfrom sanic.response import HTTPResponseapp = Sanic()@app.route(\"/\")async def test(request): return HTTPResponse(\"Hello, world\")if __name__ == \"__main__\": app.run(port=8892) 6.test_django.py Django # views.pyfrom django.http import HttpResponsedef hello(request): return HttpResponse(\"Hello, world\") 7.test_go_http.go Go http package mainimport ( \"net/http\" \"runtime\")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"Hello, world\")) &#125;) http.ListenAndServe(\"127.0.0.1:8894\", nil)&#125; 8.test_go_httprouter.go GO httprouter package mainimport ( \"net/http\" \"github.com/julienschmidt/httprouter\" \"runtime\")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) router := httprouter.New() router.HandlerFunc(\"GET\", \"/\", func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"Hello, world\")) &#125;) http.ListenAndServe(\"127.0.0.1:8895\", router)&#125; 9.test_go_fasthttp.go Go fasthttp package mainimport ( \"github.com/valyala/fasthttp\" \"runtime\")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) requestHandler := func(ctx *fasthttp.RequestCtx) &#123; ctx.Write([]byte(\"Hello, world\")) &#125; fasthttp.ListenAndServe(\"127.0.0.1:8896\", requestHandler)&#125;","categories":[],"tags":[{"name":"bench","slug":"bench","permalink":"https://imhanjm.com/tags/bench/"}]},{"title":"Go快速笔记","slug":"Go快速笔记","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2016/12/31/Go快速笔记/","link":"","permalink":"https://imhanjm.com/2016/12/31/Go快速笔记/","excerpt":"","text":"1. := 与var定义在函数中，:= 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。 函数外的每个语句都必须以关键字开始（var、func、等等），:= 结构不能使用在函数外。 常量用const定义 slice channle map 必须使用make函数来定义 new 分配内存后置零,返回指针 make 分配内存后初始化, 返回对象 在满足下列条件时，已被声明的变量 v 可出现在:= 声明中： 本次声明与已声明的 v 处于同一作用域中,（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量v） 在初始化中与其类型相应的值才能赋予 v，且在此次声明中至少另有一个变量是新声明的。 2. 基本数据类型boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名 // 代表一个Unicode码float32 float64complex64 complex128 单引号字符常量表示 Unicode Code Point，⽀支持 \\uFFFF、\\U7FFFFFFF、\\xFF 格式。 对应 rune 类型，UCS-4。var c1, c2 rune = &apos;\\u6211&apos;, &apos;们&apos; 3.Channel channel 操作符 &lt;- ,操作符只有这一个,这样就不会搞错位置了 发送者可以 close 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过 v, ok := &lt;-ch之后 ok 会被设置为 false。 循环 for i := range c 会不断从 channel 接收值，直到它被关闭。 注意： 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。 还要注意： channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 range。 4.selectselect 语句使得一个 goroutine 在多个通讯操作上等待。 select 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。 当 select 中的其他条件分支都没有准备好的时候，default 分支会被执行。 为了非阻塞的发送或者接收，可使用 default 分支： select &#123;case i := &lt;-c: // 使用 idefault: // 从 c 读取会阻塞&#125; 5.for range 遍历 range 会复制对象for key, value := range oldMap &#123; newMap[key] = value&#125; //若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了： for key := range m &#123; if key.expired() &#123; delete(m, key) &#125;&#125; 6.Switchswitch 可以什么都不写 当多级if else使用 还可以当做判断类型使用 t.(type) 只能在switch使用 switch t := t.(type) 7.Mapkey不存在不会报错，会返回与map的value的类型对应的零值. 用if _,ok:=someMap[key];ok {} 来判断有没有值 8.Print 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 fmt.Fprint 一类的格式化打印函数可接受任何实现了io.Writer接口的对象作为第一个实参:如os.Stdout``os.Stderr fmt.Printf %v（对应“值”）map中的键可能按任意顺序输出。 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 当遇到 string 或 []byte 值时， 可使用 %q 产生带引号的字符串；而格式 %#q 会尽可能使用反引号。 %T 类型 若你想控制自定义类型的默认格式，只需为该类型定义一个具有 String() string 签名的方法。 9.append 中extendx := []int&#123;1,2,3&#125;y := []int&#123;4,5,6&#125;x = append(x, y...)fmt.Println(x) 10.类型转换要提取我们知道在该值中的字符串，可以这样： str := value.(string)但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况， 需使用“逗号, ok”惯用测试它能安全地判断该值是否为字符串：str, ok := value.(string) if ok &#123; fmt.Printf(\"字符串值为 %q\\n\", str) &#125; else &#123; fmt.Printf(\"该值非字符串\\n\") &#125; 若类型断言失败，str 将继续存在且为字符串类型，但它将拥有零值，即空字符串。 11. x:=xreq := req但在Go中这样做是合法且惯用的。你用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个Go程保持唯一。比如gorm中 12.函数变参 变参本质上就是 slice。只能有⼀一个，且必须是最后⼀一个。 func test(s string, n ...int) string &#123; var x int for _, i := range n &#123; x += i &#125;return fmt.Sprintf(s, x)&#125;func main() &#123; println(test(&quot;sum: %d&quot;, 1, 2, 3)) &#125; 使⽤用 slice 对象做变参时，必须展开。func main() &#123; s := []int&#123;1, 2, 3&#125;println(test(&quot;sum: %d&quot;, s...)) &#125; 匿名函数可赋值给变量，做为结构字段，或者在 channel ⾥里传送。 13.Deferfunc add(x, y int) (z int) &#123; defer func() &#123; println(z) // 输出: 203 &#125;() z = x + y return z + 200 // 执⾏行顺序: (z = z + 200) -&gt; (call defer) -&gt; (ret)&#125; 多个 defer 注册，按 FILO 次序执⾏行。哪怕函数或某个延迟调⽤用发⽣生错误，这些调⽤用依旧 会被执⾏行。 func test(x int) &#123; defer println(&quot;a&quot;) defer println(&quot;b&quot;) defer func() &#123; println(100 / x) &#125;() defer println(&quot;c&quot;) // div0 异常未被捕获，逐步往外传递，最终终⽌止进程。&#125;func main() &#123; test(0) &#125; 输出：c b a panic: runtime error: integer divide by zero 14. error捕获函数 recover 只有在延迟调⽤用内直接调⽤用才会终⽌止错误，否则总是返回 nil。任何未捕获的错误都会沿调⽤用堆栈向外传递。 导致关键流程出现不可修复性错误的 使⽤用 panic，其他使⽤用 error。 15. 数组a := [3]int&#123;1, 2&#125;// 未初始化元素值为 0。 b := [...]int&#123;1, 2, 3, 4&#125;// 通过初始化值确定数组⻓长度。c := [5]int&#123;2: 100, 4:200&#125; // 使⽤用索引号初始化元素。d := [...]struct &#123; name string age uint8 &#125;&#123; &#123;&quot;user1&quot;, 10&#125;, &#123;&quot;user2&quot;, 20&#125;, &#125; // 可省略元素类型。 // 别忘了最后⼀一⾏行的逗号。⽀支持多维数组。a := [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125; b := [...][2]int&#123;&#123;1, 1&#125;, &#123;2, 2&#125;, &#123;3, 3&#125;&#125; // 第 2 纬度不能⽤用 &quot;...&quot;。 16. slicearray和slice是不同的类型,不同长度的array类型不同 slice是[]int array是[n]int 官方文档中说In Go, array is a fixed length of continuous memory with specified type, while slice is just a reference which points to an underlying array. Since they are different types, they can&apos;t assign value each other directly.","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"}]}]}