{"meta":{"title":"hello","subtitle":null,"description":"hanjm's blog","author":"hanjm","url":"https://imhanjm.com"},"pages":[],"posts":[{"title":"GO Logger 日志实践","slug":"GO logger 日志实践","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2017/05/19/GO logger 日志实践/","link":"","permalink":"https://imhanjm.com/2017/05/19/GO logger 日志实践/","excerpt":"","text":"分析一下用过的打印日志的log包 Go标准库自带log, 这个log的func比较少, 没有区分level, 但足够简单, 有prefix功能, 可以设置flag来控制时间格式, caller的文件名和行数, 其他标注库如 net/http database/sql 等也用了此包. 对自带的log进行包装, 加入level, 颜色. 如ngaut/log, 这个log star数并不多, 还是从最近很火的一个项目pingcap/tidb里看到的, 有点小清新的感觉, 但这个log可能只是为tidb使用的, 缺少自带log的一些方法, 导致没法使用在一些可以定制logger的第三方库如gorm中. 于是我fork了一下https://github.com/hanjm/log, 增加了一些方法. logger.NewNormalLogger() use useful flag: Ldate|Ltime|Lshortfile logger.NewCustomLogger() can set flag, level, prefix, writer in one function logger.SetFlags() can set logger&apos;s flag logger.SetPrefix() can set logger&apos;s prefix logger.Print() alias logger.Info() logger.Printf() alias logger.Infof() ``` 3. 完全自己实现的log, 结构化输出, 通常是key=value或json, 有名的有[logrus](https://github.com/sirupsen/logrus), [zap](https://github.com/uber-go/zap)等. 第一次看到logrus感觉美极了, 于是大量使用, 直到在关注tidb的时候收到带日志的issues邮件, 里面的日志带了caller, 感觉很有用, 于是去搜logrus的issue看有没有这个功能, 搜到了一个issue&lt;https://github.com/sirupsen/logrus/issues/63&gt;, 讨论了三年这个功能还没加上, 只好放弃美丽的logrus, 找到了替代品zap, zap的设计非常好, 定制性强. log是经常调用的代码, 每次调用不可避免地要进行内存分配, 分配次数和每次分配的内存大小将影响性能. 对log内容的处理也是一个涉及到性能的点, 像log.Printf参数是interface&#123;&#125;, logrus的field是map[stirng]interface&#123;&#125;, 打印interface&#123;&#125;只能靠reflect, Go是静态强类型语言, 用反射的开销比较大, 所以zap使用了手动指定类型的方式, 从zap提供的benchmark上开看, 性能提升还是蛮大的, 虽然相比logrus使用起来更麻烦, 但为了性能, 还是值得的.## 总结1. 为了方便进行日志分析, 统一用json, 这样用elk是可以免去定制正则表达式存储到elasticSearch的field中.2. net/http database/sql 及一些第三方包可能直接使用了标注库的log, 有个trick可以改变所有使用标注库log的行为, 通过`log.SetOutput(w io.Writer)`来改变位置, w是一个实现了`Write(p []byte) (n int, err error)`方法的io.Writer即可.3. runtime.Caller可以得到调用者的pc, 文件名, 文件行数, runtime.FuncForPC(pc).Name()可以得到pc所在的函数名, 对于debug非常有帮助. 但有一定性能开销, 所以方案是, 对于http server的access log, 没有必要使用带caller的日志, 而对于http api具体实现的函数内的log, 有必要记录caller, 而且光有文件名和行数还不够, 毕竟改了代码行数就变了, 而函数名一般不会变, 带上函数名会更直观.4. GitHub搜了一圈, 好多公司都会定制自己的log, 如tidb的[ngaut/log](https://github.com/ngaut/log), 七牛的[qiniu/log](https://github.com/qiniu/log), 饿了么的[eleme/log](https://github.com/eleme/log), mailgun的[mailgun/log](https://github.com/mailgun/log), 是的我也造一个小轮子.&lt;https://github.com/hanjm/zaplog&gt; package zaplog import ( “bytes” “go.uber.org/zap” “go.uber.org/zap/zapcore” “go.uber.org/zap/zapgrpc” “log” “runtime” “strings”) func init() { log.SetFlags(log.Llongfile) log.SetOutput(&amp;zapWriter{NewNoCallerLogger(false)})} type zapWriter struct { logger *zap.Logger} // Write implement io.Writer, as std log’s outputfunc (w zapWriter) Write(p []byte) (n int, err error) { i := bytes.Index(p, []byte(“:”)) + 1 j := bytes.Index(p[i:], []byte(“:”)) + 1 + i caller := bytes.TrimRight(p[:j], “:”) // last index of / i = bytes.LastIndex(caller, []byte(“/“)) // penultimate index of / i = bytes.LastIndex(caller[:i], []byte(“/“)) w.logger.Info(“stdLog”, zap.ByteString(“caller”, caller[i+1:]), zap.ByteString(“log”, bytes.TrimSpace(p[j:]))) return len(p), nil} // CallerEncoder will add caller to log. format is “filename:lineNum:funcName”, e.g:”zaplog/zaplog_test.go:15:zaplog.TestNewLogger”func CallerEncoder(caller zapcore.EntryCaller, enc zapcore.PrimitiveArrayEncoder) { enc.AppendString(strings.Join([]string{caller.TrimmedPath(), runtime.FuncForPC(caller.PC).Name()}, “:”))} func newLoggerConfig(debugLevel bool) (loggerConfig zap.Config) { loggerConfig = zap.NewProductionConfig() loggerConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder loggerConfig.EncoderConfig.EncodeCaller = CallerEncoder if debugLevel { loggerConfig.Level = zap.NewAtomicLevelAt(zap.DebugLevel) } return} // NewCustomLoggers is a shortcut to get normal logger, noCallerLogger and compatibleLoggerfunc NewCustomLoggers(debugLevel bool) (logger, noCallerLogger zap.Logger, compatibleLogger zapgrpc.Logger) { loggerConfig := newLoggerConfig(debugLevel) logger, err := loggerConfig.Build() if err != nil { panic(err) } loggerConfig.DisableCaller = true noCallerLogger, err = loggerConfig.Build() if err != nil { panic(err) } compatibleLogger = zapgrpc.NewLogger(logger.WithOptions(zap.AddCallerSkip(1))) return} // NewLogger return a normal loggerfunc NewLogger(debugLevel bool) (logger *zap.Logger) { loggerConfig := newLoggerConfig(debugLevel) logger, err := loggerConfig.Build() if err != nil { panic(err) } return} // NewNoCallerLogger return a no caller key value, will be fasterfunc NewNoCallerLogger(debugLevel bool) (noCallerLogger *zap.Logger) { loggerConfig := newLoggerConfig(debugLevel) loggerConfig.DisableCaller = true noCallerLogger, err := loggerConfig.Build() if err != nil { panic(err) } return} // NewCompatibleLogger return a logger which compatible to std log package function. log level is info// log.Print(v …interface) log.Printf(format string, v …interface) log.Println(v …interface{})// log.Panic() log.Panicf()// log.Fatal() log.Fatalf()func NewCompatibleLogger(debugLevel bool) (compatibleLogger *zapgrpc.Logger) { compatibleLogger = zapgrpc.NewLogger(NewNoCallerLogger(debugLevel).WithOptions(zap.AddCallerSkip(1))) return}```","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"log","slug":"log","permalink":"https://imhanjm.com/tags/log/"}]},{"title":"Linux Cli下酷工具收集(持续)","slug":"Linux cli下酷工具收集(持续)","date":"un66fin66","updated":"un55fin55","comments":true,"path":"2017/05/06/Linux cli下酷工具收集(持续)/","link":"","permalink":"https://imhanjm.com/2017/05/06/Linux cli下酷工具收集(持续)/","excerpt":"","text":"mycli. ipython之于Python, mycli之于mysql. 当然还有pgcli. Python写的工具. Github地址:https://github.com/dbcli/mycli youtube-dl. youtube下载器, 能直接下载youtube视频列表. Python写的工具. oh-my-zsh的z命令. 手动输入一个很长的路径名不停地tab很麻烦, 配置了oh-my-zsh的话可以启用z命令(edit: ~/.zshrc line: plugins=(git python z tmux)), z 文件夹名 就可以跳转到常用目录中最符合输入文件夹名的文件夹中, 非常方便, GitHub地址https://github.com/robbyrussell/oh-my-zsh privoxy. brew pip npm install、docker pull总是慢如蜗牛? privoxy能将shadowsocks的socks代理(127.0.0.1:1080)转换为http/https代理, 有个奇特的地方是把它把文档写在配置文件的注释里, config文件有2271行, 初让人以为配置起来会巨复杂, 实际上基本的功能两行配置即可. listen-address配置为0.0.0.0:8118, 局域网内其他设备也可以走此代理:8118. 官网https://www.privoxy.org/ listen-address 0.0.0.0:8118forward-socks5 / localhost:1080 . 然后在.zshrc或.bashrc中加入一下命令就可以通过proxy dproxy来切换是否在本终端下使用代理了. function proxy()&#123; export http_proxy=http://127.0.0.1:8118 export https_proxy=https://127.0.0.1:8118&#125;function dproxy()&#123; unset http_proxy unset https_proxy&#125; kcptun. bandwagon上的shadowsocks越来越慢, 不用kcptun加速没法正常使用, 只能不太厚道地超量发包了. GitHub地址https://github.com/xtaci/kcptun","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://imhanjm.com/tags/Linux/"},{"name":"Cool tools","slug":"Cool-tools","permalink":"https://imhanjm.com/tags/Cool-tools/"}]},{"title":"MacOS下酷工具收集(持续)","slug":"MacOS下酷工具收集(持续)","date":"un66fin66","updated":"un44fin44","comments":true,"path":"2017/05/06/MacOS下酷工具收集(持续)/","link":"","permalink":"https://imhanjm.com/2017/05/06/MacOS下酷工具收集(持续)/","excerpt":"","text":"LaunchRocket. 系统偏好设置中的用户与群组可以添加登录项脚本, 但对于需要root权限启动的应用无解, 脚本会卡在输入密码. LaunchRocket能优雅解决.(当然, 还有一种魔法方法: 用docker加--restart always的container或docker swarm service 跑, docker启动时会自动启动这些container/service) GitHub地址https://github.com/jimbojsb/launchrocket Snip. Windows下有Winsnap、FastStone、Snipaste等此等优秀的截图软件, 相比之下, Mac上的截图软件要逊色不少. Winsnap有个很方便的特性是截图可以默认复制到剪切板, 很容易粘贴到其他软件去, Mac上snip也有这个特性, snip是一款腾讯开发的截图软件, 官网http://snip.qq.com/ Macdown. 好用优雅免费的Markdown书写工具. GitHub地址https://github.com/MacDownApp/macdown Homebrew. yum/dnf之于centOS, apt之于Ubuntu, pacman之于ArchLinux, brew之于macOS, brew install简直不能太爽. 官网https://brew.sh/ Homebrew-Cask. brew install不能安装chrome Macdown这样的GUI app, Homebrew-Cask扩展了brew, GitHub地址https://github.com/caskroom/homebrew-cask privoxy. brew pip npm install、docker pull总是慢如蜗牛? privoxy能将shadowsocks的socks代理(127.0.0.1:1080)转换为http/https代理, 有个奇特的地方是把它把文档写在配置文件的注释里, config文件有2271行, 初让人以为配置起来会巨复杂, 实际上基本的功能两行配置即可. listen-address配置为0.0.0.0:8118, 局域网内其他设备也可以走此代理:8118. 官网https://www.privoxy.org/ listen-address 0.0.0.0:8118forward-socks5 / localhost:1080 . 然后在.zshrc或.bashrc中加入一下命令就可以通过proxy dproxy来切换是否在本终端下使用代理了. function proxy()&#123; export http_proxy=http://127.0.0.1:8118 export https_proxy=https://127.0.0.1:8118 export HTTP_PROXY=http://127.0.0.1:8118 export HTTPS_PROXY=https://127.0.0.1:8118&#125;function dproxy()&#123; unset http_proxy unset https_proxy unset HTTP_PROXY unset HTTPS_PROXY&#125; kcptun. bandwagon上的shadowsocks越来越慢, 不用kcptun加速没法正常使用, 只能不太厚道地超量发包了. GitHub地址https://github.com/xtaci/kcptun oh-my-zsh的z命令. 手动输入一个很长的路径名不停地tab很麻烦, 配置了oh-my-zsh的话可以启用z命令(edit: ~/.zshrc line: plugins=(git python z tmux)), z 文件夹名 就可以跳转到常用目录中最符合输入文件夹名的文件夹中, 非常方便, GitHub地址https://github.com/robbyrussell/oh-my-zsh aria2. 非常厉害的下载器, brew install aria2即可. GitHub地址:https://github.com/aria2/aria2 GUI Client:https://github.com/yangshun1029/aria2gui BaiduExporter. 百度网盘文件导出到aria2下载, GitHub地址https://github.com/acgotaku/BaiduExporter Chrome插件加白描述文件. 有时需要安装一些在商店下架了的扩展, 比如BaiduExporter, 在扩展页面安装后重启chrome会提示此扩展程序并非来自chrome商店,启用开关灰色无法启用, 可以下载此描述文件将特定扩展id加入白名单. https://hencolle.com/2016/10/16/baidu_exporter/ 坚果云.同步配置文件,pdf书非常方便. Monaco字体. 非常舒服的等宽代码字体 https://github.com/hanjm/codeFont","categories":[],"tags":[{"name":"Cool tools","slug":"Cool-tools","permalink":"https://imhanjm.com/tags/Cool-tools/"},{"name":"Macos","slug":"Macos","permalink":"https://imhanjm.com/tags/Macos/"}]},{"title":"Mysql 连接池问题","slug":"mysql连接池问题","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2017/04/26/mysql连接池问题/","link":"","permalink":"https://imhanjm.com/2017/04/26/mysql连接池问题/","excerpt":"","text":"最近应用日志里发现了mysql偶尔会出现问题 [mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56346-&gt;127.0.0.1:3306: write: broken pipe[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56346-&gt;127.0.0.1:3306: write: broken pipe[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56350-&gt;127.0.0.1:3306: write: broken pipe[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56350-&gt;127.0.0.1:3306: write: broken pipe 找GitHub issues, 提到了和mysql的wait_timeout变量有关系, https://github.com/go-sql-driver/mysql/issues/446, 于是找MySQL文档https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#idm140549060476496. 相关说明如下:The number of seconds the server waits for activity on a noninteractive connection before closing it.On thread startup, the session wait_timeout value is initialized from the global wait_timeout value or from the global interactive_timeout value, depending on the type of client (as defined by the CLIENT_INTERACTIVE connect option to mysql_real_connect()). See also interactive_timeout. 默认是28800s, 8小时.mysql&gt; show variables like &apos;%wait_timeout%&apos;; +--------------------------+----------+| Variable_name | Value |+--------------------------+----------+| innodb_lock_wait_timeout | 50 || lock_wait_timeout | 31536000 || wait_timeout | 28800 |+--------------------------+----------+3 rows in set (0.00 sec) 解决办法:db.SetConnMaxLifetime(time.Hour*7)","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"},{"name":"mysql","slug":"mysql","permalink":"https://imhanjm.com/tags/mysql/"},{"name":"连接池","slug":"连接池","permalink":"https://imhanjm.com/tags/连接池/"}]},{"title":"Go strings.TrimLeft() strings.TrimPrefix().md","slug":"Go-strings.TrimLeft-strings.TrimPrefix","date":"un11fin11","updated":"un66fin66","comments":true,"path":"2017/04/24/Go-strings.TrimLeft-strings.TrimPrefix/","link":"","permalink":"https://imhanjm.com/2017/04/24/Go-strings.TrimLeft-strings.TrimPrefix/","excerpt":"","text":"今天在调试时, 有个函数的返回的结果很奇怪, 和预期的输入差了一个字符, 而review代码时却没发现什么问题, 后面各种加logger.Debugf()才发现是strings.TrimLeft()这个函数表现得和自己的预期不一致, 从函数名上看这个是删除字符串左边的字符串, 但是传入一个带:的字符串去调用,发现:后面的字符也被Trim了, 于是去Github issues上搜了下这个问题https://github.com/golang/go/issues/19371, 有人也感觉奇怪也反馈过, 解释是 The second argument to Trim is a set of code points, not a prefix/suffix. , 于是去翻了下文档, 确实是这样的. TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed. 问题复现代码(go 1.8) https://play.golang.org/p/YtmVQIf2_i: package mainimport ( \"fmt\" \"strings\")func main() &#123; str := \"friends:d15fc7bb-1e67-11e7-b8a5-00163e008796\" prefix1 := \"friends:\" prefix2 := \"friends\" fmt.Printf(\"%v\\n\", strings.TrimLeft(str, prefix1)) fmt.Printf(\"%v\\n\", strings.TrimPrefix(str, prefix1)) fmt.Printf(\"%v\\n\", strings.TrimLeft(str, prefix2)) fmt.Printf(\"%v\\n\", strings.TrimPrefix(str, prefix2))&#125; output: 15fc7bb-1e67-11e7-b8a5-00163e008796d15fc7bb-1e67-11e7-b8a5-00163e008796:d15fc7bb-1e67-11e7-b8a5-00163e008796:d15fc7bb-1e67-11e7-b8a5-00163e008796","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"}]},{"title":"Nginx HTTP/2 编译安装","slug":"Nginx HTTP2编译安装","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2017/04/20/Nginx HTTP2编译安装/","link":"","permalink":"https://imhanjm.com/2017/04/20/Nginx HTTP2编译安装/","excerpt":"","text":"yum apt等包管理系统安装的软件有时候比较旧, 导致一些莫名其妙的问题. 最近在给Nginx加HTTP/2模块中, 编译时加上了--with-http_v2_module参数, 但Chrome请求发现还是不是http2, 后面发现是OpenSSL版本太低. 踩过这一坑后, 感觉Linux下部分软件最好还是自己编译安装比较妥, 如果编译过程出错, 搜下错误信息, 一般是基础依赖没有安装, 很好解决. 官方的源码编译指南https://nginx.org/en/docs/configure.htmlhttps://nginx.org/en/docs/http/ngx_http_v2_module.html (这里写了需要OpenSSL1.0.2以上版本), 很多选项都有合适的默认值, 比如–prefix=/usr/local/nginx, 所以只需要指定自己需要的字段 --user=www-data // 习惯将web相关的服务以www-data用户运行, 如没有此用户可以创建一个也可不加此项按默认nobody用户--group=www-data--with-http_v2_module // 默认选项不带http2--with-http_ssl_module // 默认选项不带ssl, 上http2必须要上ssl的--with-stream // https://nginx.org/en/docs/stream/ngx_stream_core_module.html--with-pcre=./pcre-8.40 // 需要(version 4.4 — 8.40)的pcre,注意Nginx不支持pcre2--with-pcre-jit // 打开pcre JIT支持--with-zlib=./zlib-1.2.11 // 需要(version 1.1.3 — 1.2.11)的zlib以支持gzip 1.安装OpenSSL 1.0.2以上版本.https://github.com/openssl/openssl/releases cd /usr/localwget https://github.com/openssl/openssl/archive/OpenSSL_1_1_0e.tar.gztar -zxf OpenSSL_1_1_0e.tar.gzcd openssl-OpenSSL_1_1_0e./config shared –prefix=/usr/local –openssldir=/usr/local/ssl/ make &amp;&amp; make install 2.官网下载Nginx包 cd /usr/localwget https://nginx.org/download/nginx-1.12.0.tar.gztar -zxf nginx-1.12.0.tar.gzcd nginx-1.12.0 3.官网下载pcre (version 1.1.3 — 1.2.11) 注意Nginx不支持pcre2,下载pcre最新版即可. 解压到Nginx解压的目录 wget https://ftp.pcre.org/pub/pcre/pcre-8.40.tar.gztar -zxf pcre-8.40.tar.gz 4.官网下载zlib(version 1.1.3 — 1.2.11) wget http://zlib.net/zlib-1.2.11.tar.gztar -zxf zlib-1.2.11.tar.gz 5.编译并安装 ./configure \\--user=www-data \\--group=www-data \\--with-http_v2_module \\--with-http_ssl_module \\--with-stream \\--with-pcre=./pcre-8.40 --with-pcre-jit \\--with-zlib=./zlib-1.2.11make &amp;&amp; make install 6.软链OpenSSL lib ln -s /usr/local/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1ln -s /usr/local/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1 7.为了方便操作,软链/usr/local/nginx/sbin/nginx到/usr/local/bin ln -s /usr/local/nginx/sbin/nginx /usr/local/bin","categories":[],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://imhanjm.com/tags/Nginx/"},{"name":"HTTP","slug":"HTTP","permalink":"https://imhanjm.com/tags/HTTP/"}]},{"title":"Python(Tornado Tornado+uvloop Tornado+uvloop2 Flask Sanic Django) Go(http Httprouter Fasthttp) RPS性能对比","slug":"Python(Tornado Tornado+uvloop tornado+uvloop2 Flask Sanic Django) Go(http httprouter fasthttp) QPS性能对比","date":"un22fin22","updated":"un33fin33","comments":true,"path":"2017/03/21/Python(Tornado Tornado+uvloop tornado+uvloop2 Flask Sanic Django) Go(http httprouter fasthttp) QPS性能对比/","link":"","permalink":"https://imhanjm.com/2017/03/21/Python(Tornado Tornado+uvloop tornado+uvloop2 Flask Sanic Django) Go(http httprouter fasthttp) QPS性能对比/","excerpt":"","text":"在v2ex上发现了一个Python的新web框架, Sanic, 基于uvloop, 其在GitHub上的性能数据十分耀眼, 于是想跟其他用过的web框架对比一下性能, 跑个分嘛. 测试环境:Python:3.6.0 Go:1.8.0 测试脚本:app用tmux启动, 然后使用Apache bench测试, n=1000, c=100, 每个app测5次 for session in test_tornado test_tornadouv test_tornadouv2 test_flask test_sanicdotmux kill-session -t $session &gt; /dev/null 2&gt;&amp;1sleep 1tmux new -s $session -d \"/root/.pyenv/versions/3.6.0/bin/python $session.py\"done# djangotmux kill-session -t test_djangosleep 1tmux new -s test_django -d \"/root/.pyenv/versions/3.6.0/bin/python test_django/manage.py runserver 127.0.0.1:8893\"for session in test_go_http test_go_httprouter test_go_fasthttpdotmux kill-session -t $sessionsleep 1tmux new -s $session -d \"go run $session.go\"donefor ((i=0;i&lt;5;i++))doecho $iab -n 1000 -c 100 http://127.0.0.1:8888/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"tornado-epoll :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8889/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"tornado-uvloop :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8890/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"tornado-uvloop2:%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8891/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"flask :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8892/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"sanic :%s\\n\",$0&#125;'ab -n 1000 -c 10 http://127.0.0.1:8893/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"django :%s\\n\",$0&#125;' # django自带的wsgi server 无法处理concurrent 100ab -n 1000 -c 100 http://127.0.0.1:8894/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"go_http :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8895/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"go_httprouter :%s\\n\",$0&#125;'ab -n 1000 -c 100 http://127.0.0.1:8896/ 2&gt; /dev/null |grep \"Requests per second\" |awk '&#123;printf \"go_fasthttp :%s\\n\",$0&#125;'done 测试结果:本机 i5-6600k@3.5GHZ 四核16GB 0tornado-epoll :Requests per second: 1714.60 [#/sec] (mean)tornado-uvloop :Requests per second: 1988.30 [#/sec] (mean)tornado-uvloop2:Requests per second: 1977.77 [#/sec] (mean)flask :Requests per second: 2167.29 [#/sec] (mean)sanic :Requests per second: 14221.72 [#/sec] (mean)django :Requests per second: 1157.64 [#/sec] (mean)go_http :Requests per second: 13847.92 [#/sec] (mean)go_httprouter :Requests per second: 14595.34 [#/sec] (mean)go_fasthttp :Requests per second: 12730.74 [#/sec] (mean)1tornado-epoll :Requests per second: 2011.02 [#/sec] (mean)tornado-uvloop :Requests per second: 1788.50 [#/sec] (mean)tornado-uvloop2:Requests per second: 1980.40 [#/sec] (mean)flask :Requests per second: 2237.84 [#/sec] (mean)sanic :Requests per second: 13614.70 [#/sec] (mean)django :Requests per second: 1145.03 [#/sec] (mean)go_http :Requests per second: 13811.01 [#/sec] (mean)go_httprouter :Requests per second: 13441.94 [#/sec] (mean)go_fasthttp :Requests per second: 12619.25 [#/sec] (mean)2tornado-epoll :Requests per second: 2056.31 [#/sec] (mean)tornado-uvloop :Requests per second: 1831.49 [#/sec] (mean)tornado-uvloop2:Requests per second: 2015.39 [#/sec] (mean)flask :Requests per second: 2124.87 [#/sec] (mean)sanic :Requests per second: 12485.80 [#/sec] (mean)django :Requests per second: 1160.55 [#/sec] (mean)go_http :Requests per second: 14014.43 [#/sec] (mean)go_httprouter :Requests per second: 13949.34 [#/sec] (mean)go_fasthttp :Requests per second: 12419.12 [#/sec] (mean)3tornado-epoll :Requests per second: 2017.32 [#/sec] (mean)tornado-uvloop :Requests per second: 1731.04 [#/sec] (mean)tornado-uvloop2:Requests per second: 2014.46 [#/sec] (mean)flask :Requests per second: 2100.02 [#/sec] (mean)sanic :Requests per second: 12459.04 [#/sec] (mean)django :Requests per second: 1164.06 [#/sec] (mean)go_http :Requests per second: 13239.77 [#/sec] (mean)go_httprouter :Requests per second: 14127.49 [#/sec] (mean)go_fasthttp :Requests per second: 12824.46 [#/sec] (mean)4tornado-epoll :Requests per second: 1810.77 [#/sec] (mean)tornado-uvloop :Requests per second: 1975.12 [#/sec] (mean)tornado-uvloop2:Requests per second: 1962.81 [#/sec] (mean)flask :Requests per second: 2234.08 [#/sec] (mean)sanic :Requests per second: 13881.95 [#/sec] (mean)django :Requests per second: 1154.90 [#/sec] (mean)go_http :Requests per second: 14399.47 [#/sec] (mean)go_httprouter :Requests per second: 13688.69 [#/sec] (mean)go_fasthttp :Requests per second: 12672.99 [#/sec] (mean) 阿里云ECS 双核8GB 0tornado-epoll :Requests per second: 542.60 [#/sec] (mean)tornado-uvloop :Requests per second: 930.95 [#/sec] (mean)tornado-uvloop2:Requests per second: 811.54 [#/sec] (mean)flask :Requests per second: 897.00 [#/sec] (mean)sanic :Requests per second: 5681.50 [#/sec] (mean)django :Requests per second: 447.41 [#/sec] (mean)go_http :Requests per second: 8551.98 [#/sec] (mean)go_httprouter :Requests per second: 9655.31 [#/sec] (mean)go_fasthttp :Requests per second: 11469.21 [#/sec] (mean)1tornado-epoll :Requests per second: 969.97 [#/sec] (mean)tornado-uvloop :Requests per second: 970.14 [#/sec] (mean)tornado-uvloop2:Requests per second: 990.24 [#/sec] (mean)flask :Requests per second: 900.50 [#/sec] (mean)sanic :Requests per second: 5789.89 [#/sec] (mean)django :Requests per second: 435.28 [#/sec] (mean)go_http :Requests per second: 8076.63 [#/sec] (mean)go_httprouter :Requests per second: 9340.99 [#/sec] (mean)go_fasthttp :Requests per second: 6024.82 [#/sec] (mean)2tornado-epoll :Requests per second: 946.98 [#/sec] (mean)tornado-uvloop :Requests per second: 975.64 [#/sec] (mean)tornado-uvloop2:Requests per second: 955.25 [#/sec] (mean)flask :Requests per second: 1021.28 [#/sec] (mean)sanic :Requests per second: 6361.36 [#/sec] (mean)django :Requests per second: 440.23 [#/sec] (mean)go_http :Requests per second: 7601.67 [#/sec] (mean)go_httprouter :Requests per second: 8123.21 [#/sec] (mean)go_fasthttp :Requests per second: 8500.00 [#/sec] (mean)3tornado-epoll :Requests per second: 944.39 [#/sec] (mean)tornado-uvloop :Requests per second: 921.12 [#/sec] (mean)tornado-uvloop2:Requests per second: 980.30 [#/sec] (mean)flask :Requests per second: 946.53 [#/sec] (mean)sanic :Requests per second: 5686.99 [#/sec] (mean)django :Requests per second: 498.31 [#/sec] (mean)go_http :Requests per second: 6297.78 [#/sec] (mean)go_httprouter :Requests per second: 8078.91 [#/sec] (mean)go_fasthttp :Requests per second: 6523.84 [#/sec] (mean)4tornado-epoll :Requests per second: 953.86 [#/sec] (mean)tornado-uvloop :Requests per second: 983.97 [#/sec] (mean)tornado-uvloop2:Requests per second: 955.04 [#/sec] (mean)flask :Requests per second: 994.77 [#/sec] (mean)sanic :Requests per second: 6877.11 [#/sec] (mean)django :Requests per second: 510.76 [#/sec] (mean)go_http :Requests per second: 8243.14 [#/sec] (mean)go_httprouter :Requests per second: 7055.97 [#/sec] (mean)go_fasthttp :Requests per second: 6183.83 [#/sec] (mean) ###结论: Sanic确实叼, 拉出Flask一大截. 由于这个测试只是简单返回”Hello, world”, Tornado的优势要在使用了aio,AsyncHTTPClient的时候才能发挥出来. 如果拿tornado当纯同步使用的话, 性能会比flask弱一点点. Django自带的wsgi server无法完成此任务. fasthttp表现的很奇怪, 可能是handler太简单的情况下sync/pool的代价超过了gc的影响, httprouter比http快一点. ###测试代码: 1.test_tornado.py Tornado 4.4.2 import tornado.ioloopimport tornado.webclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\")def make_app(): return tornado.web.Application([ (r\"/\", MainHandler), ])if __name__ == \"__main__\": app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() 2.test_tornadouv.py Tornado+uvloop(pip install tornadouvloop) import tornado.ioloopimport tornado.webfrom tornadouvloop import TornadoUvloopclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\")def make_app(): return tornado.web.Application([ (r\"/\", MainHandler), ])if __name__ == \"__main__\": app = make_app() app.listen(8889) tornado.ioloop.IOLoop.configure(TornadoUvloop) tornado.ioloop.IOLoop.current().start() 3.test_tornadouv2.py Tornado+uvloop2(pip install tornaduv) import tornado.ioloopimport tornado.webfrom tornaduv import UVLoopclass MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\")def make_app(): return tornado.web.Application([ (r\"/\", MainHandler), ])if __name__ == \"__main__\": app = make_app() app.listen(8890) tornado.ioloop.IOLoop.configure(UVLoop) tornado.ioloop.IOLoop.current().start() 4.test_flask.py Flask 0.12 from flask import Flaskapp = Flask(__name__)@app.route(\"/\")def hello(): return \"Hello, world\"if __name__ == \"__main__\": app.run(port=8891) 5.test_sanic.py Sanic 0.4.1 from sanic import Sanicfrom sanic.response import HTTPResponseapp = Sanic()@app.route(\"/\")async def test(request): return HTTPResponse(\"Hello, world\")if __name__ == \"__main__\": app.run(port=8892) 6.test_django.py Django # views.pyfrom django.http import HttpResponsedef hello(request): return HttpResponse(\"Hello, world\") 7.test_go_http.go Go http package mainimport ( \"net/http\" \"runtime\")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"Hello, world\")) &#125;) http.ListenAndServe(\"127.0.0.1:8894\", nil)&#125; 8.test_go_httprouter.go GO httprouter package mainimport ( \"net/http\" \"github.com/julienschmidt/httprouter\" \"runtime\")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) router := httprouter.New() router.HandlerFunc(\"GET\", \"/\", func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"Hello, world\")) &#125;) http.ListenAndServe(\"127.0.0.1:8895\", router)&#125; 9.test_go_fasthttp.go Go fasthttp package mainimport ( \"github.com/valyala/fasthttp\" \"runtime\")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) requestHandler := func(ctx *fasthttp.RequestCtx) &#123; ctx.Write([]byte(\"Hello, world\")) &#125; fasthttp.ListenAndServe(\"127.0.0.1:8896\", requestHandler)&#125;","categories":[],"tags":[{"name":"bench","slug":"bench","permalink":"https://imhanjm.com/tags/bench/"}]},{"title":"Go快速笔记","slug":"Go快速笔记","date":"un66fin66","updated":"un00fin00","comments":true,"path":"2016/12/31/Go快速笔记/","link":"","permalink":"https://imhanjm.com/2016/12/31/Go快速笔记/","excerpt":"","text":"1. := 与var定义在函数中，:= 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。 函数外的每个语句都必须以关键字开始（var、func、等等），:= 结构不能使用在函数外。 常量用const定义 slice channle map 必须使用make函数来定义 new 分配内存后置零,返回指针 make 分配内存后初始化, 返回对象 在满足下列条件时，已被声明的变量 v 可出现在:= 声明中： 本次声明与已声明的 v 处于同一作用域中,（若 v 已在外层作用域中声明过，则此次声明会创建一个新的变量v） 在初始化中与其类型相应的值才能赋予 v，且在此次声明中至少另有一个变量是新声明的。 2. 基本数据类型boolstringint int8 int16 int32 int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名 // 代表一个Unicode码float32 float64complex64 complex128 单引号字符常量表示 Unicode Code Point，⽀支持 \\uFFFF、\\U7FFFFFFF、\\xFF 格式。 对应 rune 类型，UCS-4。var c1, c2 rune = &apos;\\u6211&apos;, &apos;们&apos; 3.Channel channel 操作符 &lt;- ,操作符只有这一个,这样就不会搞错位置了 发送者可以 close 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过 v, ok := &lt;-ch之后 ok 会被设置为 false。 循环 for i := range c 会不断从 channel 接收值，直到它被关闭。 注意： 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。 还要注意： channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 range。 4.selectselect 语句使得一个 goroutine 在多个通讯操作上等待。 select 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。 当 select 中的其他条件分支都没有准备好的时候，default 分支会被执行。 为了非阻塞的发送或者接收，可使用 default 分支： select &#123;case i := &lt;-c: // 使用 idefault: // 从 c 读取会阻塞&#125; 5.for range 遍历 range 会复制对象for key, value := range oldMap &#123; newMap[key] = value&#125; //若你只需要该遍历中的第一个项（键或下标），去掉第二个就行了： for key := range m &#123; if key.expired() &#123; delete(m, key) &#125;&#125; 6.Switchswitch 可以什么都不写 当多级if else使用 还可以当做判断类型使用 t.(type) 只能在switch使用 switch t := t.(type) 7.Mapkey不存在不会报错，会返回与map的value的类型对应的零值. 用if _,ok:=someMap[key];ok {} 来判断有没有值 8.Print 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 fmt.Fprint 一类的格式化打印函数可接受任何实现了io.Writer接口的对象作为第一个实参:如os.Stdout``os.Stderr fmt.Printf %v（对应“值”）map中的键可能按任意顺序输出。 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 当遇到 string 或 []byte 值时， 可使用 %q 产生带引号的字符串；而格式 %#q 会尽可能使用反引号。 %T 类型 若你想控制自定义类型的默认格式，只需为该类型定义一个具有 String() string 签名的方法。 9.append 中extendx := []int&#123;1,2,3&#125;y := []int&#123;4,5,6&#125;x = append(x, y...)fmt.Println(x) 10.类型转换要提取我们知道在该值中的字符串，可以这样： str := value.(string)但若它所转换的值中不包含字符串，该程序就会以运行时错误崩溃。为避免这种情况， 需使用“逗号, ok”惯用测试它能安全地判断该值是否为字符串：str, ok := value.(string) if ok &#123; fmt.Printf(\"字符串值为 %q\\n\", str) &#125; else &#123; fmt.Printf(\"该值非字符串\\n\") &#125; 若类型断言失败，str 将继续存在且为字符串类型，但它将拥有零值，即空字符串。 11. x:=xreq := req但在Go中这样做是合法且惯用的。你用相同的名字获得了该变量的一个新的版本， 以此来局部地刻意屏蔽循环变量，使它对每个Go程保持唯一。比如gorm中 12.函数变参 变参本质上就是 slice。只能有⼀一个，且必须是最后⼀一个。 func test(s string, n ...int) string &#123; var x int for _, i := range n &#123; x += i &#125;return fmt.Sprintf(s, x)&#125;func main() &#123; println(test(&quot;sum: %d&quot;, 1, 2, 3)) &#125; 使⽤用 slice 对象做变参时，必须展开。func main() &#123; s := []int&#123;1, 2, 3&#125;println(test(&quot;sum: %d&quot;, s...)) &#125; 匿名函数可赋值给变量，做为结构字段，或者在 channel ⾥里传送。 13.Deferfunc add(x, y int) (z int) &#123; defer func() &#123; println(z) // 输出: 203 &#125;() z = x + y return z + 200 // 执⾏行顺序: (z = z + 200) -&gt; (call defer) -&gt; (ret)&#125; 多个 defer 注册，按 FILO 次序执⾏行。哪怕函数或某个延迟调⽤用发⽣生错误，这些调⽤用依旧 会被执⾏行。 func test(x int) &#123; defer println(&quot;a&quot;) defer println(&quot;b&quot;) defer func() &#123; println(100 / x) &#125;() defer println(&quot;c&quot;) // div0 异常未被捕获，逐步往外传递，最终终⽌止进程。&#125;func main() &#123; test(0) &#125; 输出：c b a panic: runtime error: integer divide by zero 14. error捕获函数 recover 只有在延迟调⽤用内直接调⽤用才会终⽌止错误，否则总是返回 nil。任何未捕获的错误都会沿调⽤用堆栈向外传递。 导致关键流程出现不可修复性错误的 使⽤用 panic，其他使⽤用 error。 15. 数组a := [3]int&#123;1, 2&#125;// 未初始化元素值为 0。 b := [...]int&#123;1, 2, 3, 4&#125;// 通过初始化值确定数组⻓长度。c := [5]int&#123;2: 100, 4:200&#125; // 使⽤用索引号初始化元素。d := [...]struct &#123; name string age uint8 &#125;&#123; &#123;&quot;user1&quot;, 10&#125;, &#123;&quot;user2&quot;, 20&#125;, &#125; // 可省略元素类型。 // 别忘了最后⼀一⾏行的逗号。⽀支持多维数组。a := [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125; b := [...][2]int&#123;&#123;1, 1&#125;, &#123;2, 2&#125;, &#123;3, 3&#125;&#125; // 第 2 纬度不能⽤用 &quot;...&quot;。 16. slicearray和slice是不同的类型,不同长度的array类型不同 slice是[]int array是[n]int 官方文档中说In Go, array is a fixed length of continuous memory with specified type, while slice is just a reference which points to an underlying array. Since they are different types, they can&apos;t assign value each other directly.","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://imhanjm.com/tags/Go/"}]}]}