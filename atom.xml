<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hello</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imhanjm.com/"/>
  <updated>2019-10-13T08:56:07.690Z</updated>
  <id>https://imhanjm.com/</id>
  
  <author>
    <name>hanjm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Prometheus(GO SDK及Grafana基本面板)</title>
    <link href="https://imhanjm.com/2019/10/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Prometheus(GO%20SDK)/"/>
    <id>https://imhanjm.com/2019/10/06/深入理解Prometheus(GO SDK)/</id>
    <published>2019-10-05T16:00:00.000Z</published>
    <updated>2019-10-13T08:56:07.690Z</updated>
    
    <content type="html"><![CDATA[<p>最近我对Prometheus刮目相看了, 服务加一行代码就能轻轻松松地监控起来服务的CPU使用率、内存、协程数、线程数、打开的文件描述符数量及软限制、重启次数等重要的基本指标, 配合Grafana建立了直观的图表, 对查问题很有帮助, 故想写写折腾Prometheus和Grafana后得到的值得一讲的实践与理解.</p><p><img src="https://raw.githubusercontent.com/hanjm/oss/master/20191013165216-i51pMV.png" alt="GO服务几个重要的基本指标Dashboard"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Prometheus是<a href="https://www.cncf.io/" target="_blank" rel="noopener">CNCF</a> 的项目之一(ps.CNCF的项目代码都值得研究), 而且还是Graduated Projects. 同时因为其主要是方便灵活的pull方式, 暴露出个http接口出来给prometheusd拉取就行了, 而push方式客户端要做更多的事情, 如果要改push的地址的话就很麻烦, 所以很多著名的项目都在用它, 比如k8s, tidb, etcd, 甚至是时序数据库influxdb都在用它.</p><p>我体会到, 很多场景很适合使用Prometheus sdk去加一些指标, 比如logger包, Error级别的消息数是一个很有用的指标; 对于消息队列的SDK, 可以用Prometheus收集客户端侧的发送时延、消费时延、消费处理耗时、消费处理出错等指标; 封装DB操作的SDK, 连接池打开的DB连接数与最大连接数是个很重要的指标; 写个HTTP Middleware, http handler的调用次数、处理时间和responseCode是感兴趣的指标.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Prometheus是Go写的, 故部署方便且跨平台, 一个二进制文件加配置文件就能跑起来.</p><p><a href="https://github.com/prometheus/prometheus/releases" target="_blank" rel="noopener">GitHub release页面</a>有各个平台的编译好的二进制文件,通常配合supervisor等进程管理工具来服务化, 也可以用docker.</p><p><a href="https://prometheus.io/docs/prometheus/latest/getting_started/" target="_blank" rel="noopener">文档</a>上有基础的配置文件示例, 复制为<code>prometheus.yml</code>即可.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./prometheus --config.file=prometheus.yml</span><br></pre></td></tr></table></figure><p><code>prometheus.yml</code>主要是定义一些全局的抓取间隔等参数以及抓取的job, 抓取的job可以指定名字、抓取间隔、抓取目标的IP端口号列表, 目标的路由路径, 额外的label等参数.</p><p>抓取指标时会自动加上<code>job=&quot;&lt;job_name&gt;&quot;</code>和<code>instance=&quot;&lt;target ip port&gt;&quot;</code>两个label, 如果想给job添加额外的固定label, 则可以在配置文件中按如下语法添加.</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    metrics_path:</span> <span class="string">"/prometheus/metrics"</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:10056']</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          service_name:</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>前面说到, Prometheus的配置文件主要就是定义要抓取的job配置, 显然新加服务要改配置文件是比较麻烦的, Prometheus的一大重要的功能点就是原生支持多种服务发现方式, 支持consul etcd等服务发现组件, 还支持非常通用的基于文件的服务发现, 即你可以定义一个写好target的IP端口号等配置的配置文件路径, 由外部程序定期去更新这个文件, prometheus会定期加载它, 更新抓取的目标, 非常灵活.</p><h1 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h1><p>Prometheus的时序指标数据由timestamp、metric name、label、value组成:</p><ul><li><p>timestamp是毫秒级的时间戳.</p></li><li><p>metric name是符合正则<code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>的字符串, 即只包含英文字母和数字及两个特殊符号_:, 不能包含横杆-这样的特殊符号.</p></li><li><p>label是一个kv都是string类型的map. </p></li><li><p>value是float64.</p></li></ul><h1 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h1><p>Prometheus的指标类型包括基本指标类型Counter和Guage及进阶指标类型Historygram和Summary.</p><p>所有指标都是在client SDK端内存存储的, 由prometheus抓取器抓取.</p><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>Counter是计数器, 单调递增的, 只有服务重启时才会清零, 比如http请求数, errorLevel的log数. 值得一提的是, prometheus的内置函数求值时会自动处理重启清零的情况. </p><p>counter的value是float64, 怎么无锁地操作float64呢? 答案是用math包将其视作uint64来操作.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *value)</span> <span class="title">Add</span><span class="params">(val <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">oldBits := atomic.LoadUint64(&amp;v.valBits)</span><br><span class="line">newBits := math.Float64bits(math.Float64frombits(oldBits) + val)</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;v.valBits, oldBits, newBits) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Guage"><a href="#Guage" class="headerlink" title="Guage"></a>Guage</h2><p>Guage是一个可增可减的数值指标, 比如CPU使用率, 内存使用率, 协程数.</p><h2 id="Historygram"><a href="#Historygram" class="headerlink" title="Historygram"></a>Historygram</h2><p>Historygram是直方图, 适合需要知道数值分布范围的场景, 比如http请求的响应时长, http请求的响应包体大小等.</p><p>直方图的组距不一定是固定的, 可以自己定义适合, 这里称其为bucket, 每一个metric value根据其数值大小落在对应的bucket.</p><p>Historygram实际上包含多个时序数据.</p><ul><li><code>&lt;basename&gt;_bucket{le=&quot;&lt;upper inclusive bound&gt;&quot;}</code>小于等于指定数值的计数.</li><li><code>&lt;basename&gt;_sum</code> 总和</li><li><code>&lt;basename&gt;_count</code> 总计数, 其值当然也等于<code>&lt;basename&gt;_bucket{le=&quot;+Inf&quot;}</code></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Summary相比Historygram是按百分位聚合好的直方图, 适合需要知道百分比分布范围的场景, 比如对于 http请求的响应时长, Historygram是侧重在于统计小于1ms的请求有多少个, 1ms~10ms的请求有多少个, 10ms以上的请求有多少个, 而Summary在于统计20%的请求的响应时间是多少, 50%的请求的响应时间是多少, 99%的请求的响应时间是多少.  Historygram是计数原始数据, 开销小, 执行查询时有对应的函数计算得到p50, p99, 而Summary是在客户端SDK测做了聚合计算得到指定的百分位, 开销更大一些.</p><h1 id="SDK的使用"><a href="#SDK的使用" class="headerlink" title="SDK的使用"></a>SDK的使用</h1><p>prometheus的Golang SDK设计得很地道, 充分利用了GO语言的特性.</p><p>在SDK中所有的指标类型都实现了<code>prometheus.Collector</code> 接口. </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collector is the interface implemented by anything that can be used by</span></span><br><span class="line"><span class="comment">// Prometheus to collect metrics. A Collector has to be registered for</span></span><br><span class="line"><span class="comment">// collection. See Registerer.Register.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The stock metrics provided by this package (Gauge, Counter, Summary,</span></span><br><span class="line"><span class="comment">// Histogram, Untyped) are also Collectors (which only ever collect one metric,</span></span><br><span class="line"><span class="comment">// namely itself). An implementer of Collector may, however, collect multiple</span></span><br><span class="line"><span class="comment">// metrics in a coordinated fashion and/or create metrics on the fly. Examples</span></span><br><span class="line"><span class="comment">// for collectors already implemented in this library are the metric vectors</span></span><br><span class="line"><span class="comment">// (i.e. collection of multiple instances of the same Metric but with different</span></span><br><span class="line"><span class="comment">// label values) like GaugeVec or SummaryVec, and the ExpvarCollector.</span></span><br><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Describe sends the super-set of all possible descriptors of metrics</span></span><br><span class="line"><span class="comment">// collected by this Collector to the provided channel and returns once</span></span><br><span class="line"><span class="comment">// the last descriptor has been sent. The sent descriptors fulfill the</span></span><br><span class="line"><span class="comment">// consistency and uniqueness requirements described in the Desc</span></span><br><span class="line"><span class="comment">// documentation. (It is valid if one and the same Collector sends</span></span><br><span class="line"><span class="comment">// duplicate descriptors. Those duplicates are simply ignored. However,</span></span><br><span class="line"><span class="comment">// two different Collectors must not send duplicate descriptors.) This</span></span><br><span class="line"><span class="comment">// method idempotently sends the same descriptors throughout the</span></span><br><span class="line"><span class="comment">// lifetime of the Collector. If a Collector encounters an error while</span></span><br><span class="line"><span class="comment">// executing this method, it must send an invalid descriptor (created</span></span><br><span class="line"><span class="comment">// with NewInvalidDesc) to signal the error to the registry.</span></span><br><span class="line">Describe(<span class="keyword">chan</span>&lt;- *Desc)</span><br><span class="line"><span class="comment">// Collect is called by the Prometheus registry when collecting</span></span><br><span class="line"><span class="comment">// metrics. The implementation sends each collected metric via the</span></span><br><span class="line"><span class="comment">// provided channel and returns once the last metric has been sent. The</span></span><br><span class="line"><span class="comment">// descriptor of each sent metric is one of those returned by</span></span><br><span class="line"><span class="comment">// Describe. Returned metrics that share the same descriptor must differ</span></span><br><span class="line"><span class="comment">// in their variable label values. This method may be called</span></span><br><span class="line"><span class="comment">// concurrently and must therefore be implemented in a concurrency safe</span></span><br><span class="line"><span class="comment">// way. Blocking occurs at the expense of total performance of rendering</span></span><br><span class="line"><span class="comment">// all registered metrics. Ideally, Collector implementations support</span></span><br><span class="line"><span class="comment">// concurrent readers.</span></span><br><span class="line">Collect(<span class="keyword">chan</span>&lt;- Metric)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prometheus.Collector</code> 接口中的方法传参都是只写的<code>chan</code>, 使得实现接口的代码无论是同步还是并行都可以. <code>Describe(chan&lt;- *Desc)</code>方法是在将Collector注册或注销时调用的, <code>Collect(chan&lt;- Metric)</code>方法是在被抓取收集指标时调用的.</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>不带label的指标类型使用<code>prometheus.NewCounter</code> <code>prometheus.NewGauge</code> <code>prometheus.NewHistogram</code> <code>prometheus.NewSummary</code>去创建并使用<code>prometheus.MustRegister</code> 注册, 一般是初始化好作为一个包内全局变量, 在init函数中注册.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">sentBytes = prometheus.NewCounter(prometheus.CounterOpts&#123;</span><br><span class="line">Namespace: <span class="string">"etcd"</span>,</span><br><span class="line">Subsystem: <span class="string">"network"</span>,</span><br><span class="line">Name:      <span class="string">"client_grpc_sent_bytes_total"</span>,</span><br><span class="line">Help:      <span class="string">"The total number of bytes sent to grpc clients."</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">receivedBytes = prometheus.NewCounter(prometheus.CounterOpts&#123;</span><br><span class="line">Namespace: <span class="string">"etcd"</span>,</span><br><span class="line">Subsystem: <span class="string">"network"</span>,</span><br><span class="line">Name:      <span class="string">"client_grpc_received_bytes_total"</span>,</span><br><span class="line">Help:      <span class="string">"The total number of bytes received from grpc clients."</span>,</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">prometheus.MustRegister(sentBytes)</span><br><span class="line">prometheus.MustRegister(receivedBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>counter的Add方法不能传负数, 否则会panic.</p><p>带label的指标类型使用<code>prometheus.NewCounterVec</code> <code>prometheus.NewGaugeVec</code> <code>prometheus.NewHistogramVec</code> <code>prometheus.NewSummaryVec</code>, 不同的label值就像空间直角坐标系中的以原点为七点的不同方向的向量一样.</p><p>调用Vec类型的<code>WithLabelValues</code>方法传入的value参数数量一定要和注册时定义的label数量一致, 否则会panic.</p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>默认情况下, Collector都是主动去计数, 但有的指标无法主动计数, 比如监控服务当前打开的DB连接数, 这个指标更适合在拉取指标时去获取值, 这个时候就可以使用<code>prometheus.NewCounterFunc</code> <code>prometheus.NewGaugeFunc</code>, 传入一个返回指标值的函数<code>func() float64</code>, 在拉取指标时就会调用这个函数, 当然, 这样定义的是没有带Label的, 如果想在拉取指标时执行自己定义的函数并且附加上label, 就只能自己定义一个实现 <code>prometheus.Collector</code>接口的指标收集器, prometheus SDK设计得足够灵活, 暴露了底层方法<code>MustNewConstMetric</code>, 使得可以很方便地实现一个这样的自定义Collector, 代码如下.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> gaugeVecFuncCollector <span class="keyword">struct</span> &#123;</span><br><span class="line">desc                        *prometheus.Desc</span><br><span class="line">gaugeVecFuncWithLabelValues []gaugeVecFuncWithLabelValues</span><br><span class="line">labelsDeduplicatedMap       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGaugeVecFunc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGaugeVecFunc</span><span class="params">(opts GaugeOpts, labelNames []<span class="keyword">string</span>)</span> *<span class="title">gaugeVecFuncCollector</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;gaugeVecFuncCollector&#123;</span><br><span class="line">desc: prometheus.NewDesc(</span><br><span class="line">prometheus.BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),</span><br><span class="line">opts.Help,</span><br><span class="line">labelNames,</span><br><span class="line">opts.ConstLabels,</span><br><span class="line">),</span><br><span class="line">labelsDeduplicatedMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Describe</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *gaugeVecFuncCollector)</span> <span class="title">Describe</span><span class="params">(ch <span class="keyword">chan</span>&lt;- *prometheus.Desc)</span></span> &#123;</span><br><span class="line">ch &lt;- dc.desc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collect</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *gaugeVecFuncCollector)</span> <span class="title">Collect</span><span class="params">(ch <span class="keyword">chan</span>&lt;- prometheus.Metric)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> dc.gaugeVecFuncWithLabelValues &#123;</span><br><span class="line">ch &lt;- prometheus.MustNewConstMetric(dc.desc, prometheus.GaugeValue, v.gaugeVecFunc(), v.labelValues...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterGaugeVecFunc </span></span><br><span class="line"><span class="comment">// 同一组labelValues只能注册一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *gaugeVecFuncCollector)</span> <span class="title">RegisterGaugeVecFunc</span><span class="params">(labelValues []<span class="keyword">string</span>, gaugeVecFunc <span class="keyword">func</span>()</span> <span class="title">float64</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// prometheus每次允许收集一次labelValues相同的metric</span></span><br><span class="line">deduplicateKey := strings.Join(labelValues, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">if</span> dc.labelsDeduplicatedMap[deduplicateKey] &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"labelValues func already registered, labelValues:%v"</span>, labelValues)</span><br><span class="line">&#125;</span><br><span class="line">dc.labelsDeduplicatedMap[deduplicateKey] = <span class="literal">true</span></span><br><span class="line">handlePanicGaugeVecFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rec := <span class="built_in">recover</span>(); rec != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">10</span> * <span class="number">1024</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">logger.Errorf(<span class="string">"gaugeVecFunc panic:%v\nstack:%s"</span>, rec, buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gaugeVecFunc()</span><br><span class="line">&#125;</span><br><span class="line">dc.gaugeVecFuncWithLabelValues = <span class="built_in">append</span>(dc.gaugeVecFuncWithLabelValues, gaugeVecFuncWithLabelValues&#123;</span><br><span class="line">gaugeVecFunc: handlePanicGaugeVecFunc,</span><br><span class="line">labelValues:  labelValues,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol><li><p>在编辑图表写查询语句时,不会显示指标类型, 所以最好看到metric name就能知道是一个什么类型的指标, 约定counter类型的指标名字以<code>_total</code>为后缀. </p></li><li><p>在编辑图表写查询语句时, 也不会显示指标类型的单位, 所以最好看到metric name就能知道是一个什么单位的指标, 比如时长要写是纳秒还是毫秒还是秒, http_request_duration_<strong>seconds</strong>, 数据大小要写是MB还是bytes, client_grpc_sent_<strong>bytes</strong>_total.</p></li><li><p>每个指标要有单个词的namespace前缀, 比如<strong>process</strong>_cpu_seconds_total,  <strong>http</strong>_request_duration_seconds.</p></li><li><p>不带label的Counter和Guage内部是个无锁的atomic uint64, 不带Label的Historygram内部是多个无锁的atomic uint64, 不带Label的Summary因为内部要聚合计算, 是有锁的, 所以并发要求高的话优先选择Historygram而不是Summary.</p></li><li><p>带label的每次会去计算label值的hash找到对应的向量, 然后去计数, 所以label数不要太多, label值的长度不要太长, label值是要可枚举的并且不能太多, 否则执行查询时慢, 面板加载慢, 存储也费空间.   label如果可以提前计算则尽量使用GetMetricWithLabelValues提前计算好得到一个普通的计数器, 减少每次计数的一次计算label的hash, 提升程序性能.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetMetricWithLabelValues replaces the method of the same name in</span></span><br><span class="line"><span class="comment">// MetricVec. The difference is that this method returns a Counter and not a</span></span><br><span class="line"><span class="comment">// Metric so that no type conversion is required.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *CounterVec)</span> <span class="title">GetMetricWithLabelValues</span><span class="params">(lvs ...<span class="keyword">string</span>)</span> <span class="params">(Counter, error)</span></span> &#123;</span><br><span class="line">   metric, err := m.MetricVec.GetMetricWithLabelValues(lvs...)</span><br><span class="line">   <span class="keyword">if</span> metric != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> metric.(Counter), err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于时长time.Duration数据类型的指标值收集, time.Since是优化过的, 直接走runtimeNano, 无需走系统调用取当前时间, 性能优于time.Now后相减, 另外, 频繁调用time.Now在性能要求高的程序中也会变成不小的开销.</p></li></ol><h1 id="查询语句promQL"><a href="#查询语句promQL" class="headerlink" title="查询语句promQL"></a>查询语句promQL</h1><p>Prometheus查询语句(PromQL)是一个相比SQL更简单也很有表达力的专用查询语言, 通过文档及例子学习.</p><p>Prometheus自带的Graph面板比较简陋, 一般情况下直接用强大的Grafana就行了, 制作图表dashboard时, 直接输入PromQL即可展示时序图表.</p><h2 id="label条件-Instant-vector-selectors"><a href="#label条件-Instant-vector-selectors" class="headerlink" title="label条件 (Instant vector selectors)"></a>label条件 (Instant vector selectors)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">"prometheus"</span>,group=<span class="string">"canary"</span>&#125;</span><br></pre></td></tr></table></figure><p>查询条件中,除了=和!=外, =~表示正则匹配, !~表示正则不匹配.</p><p>查询条件也可以作用在metric name上, 语法有点像Python的__前缀的魔法, 如用  <code>{__name__=~&quot;job:.*&quot;}</code>表示选择名字符合<code>job:.*</code>这样的正则的metric.</p><h2 id="范围条件-Range-Vector-Selectors"><a href="#范围条件-Range-Vector-Selectors" class="headerlink" title="范围条件(Range Vector Selectors)"></a>范围条件(Range Vector Selectors)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http_requests_total&#123;job=<span class="string">"prometheus"</span>&#125;[<span class="number">5</span>m]</span><br></pre></td></tr></table></figure><p>范围条件中, 时长字符串语法和GO一样, s代表秒, m代表分, h代表小时, d代表天, w代表星期, y代表年.</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ol><li><code>changes()</code>  变化次数</li><li><code>delta(v range-vector)</code>  平均变化量, 只适用于guage</li><li><code>idelta(v range-vector)</code> 即时变化量, 只适用于guage</li><li><code>histogram_quantile(φ float, b instant-vector)</code> histogram专用函数, 用来计算p99 p90等百分位的summary. 例子<code>histogram_quantile(0.9, avg(rate(http_request_duration_seconds_bucket[10m])) by (job, le))</code></li><li><code>increase(v range-vector)</code> 增量, 只适用于counter</li><li><code>rate</code> - 平均QPS</li><li><code>irate</code> - 即时QPS, 如果原始数据变化快, 可以使用更敏感的irate</li></ol><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><p>这里列举一些我通过搜索及自行摸索出来的对于Prometheus GO SDK默认收集的指标的PromQL Snippet.</p><ol><li><p>CPU使用率: <code>rate(process_cpu_seconds_total[1m])* 100</code></p></li><li><p>系统内存使用率: <code>go_memstats_sys_bytes</code></p></li><li><p>重启次数: <code>changes(process_start_time_seconds[5m])</code></p></li></ol><h1 id="Grafana面板"><a href="#Grafana面板" class="headerlink" title="Grafana面板"></a>Grafana面板</h1><p>编辑Grafana面板时, 有几个技巧:</p><ol><li>Query界面可以设置下方说明条Legend的格式, 支持双花括号形式<code></code>的模板语法.</li><li>Visualization界面可以设置坐标轴的单位, 比如百分比, 数据大小单位, 时长单位等等, 让Y轴的值更具有可读性.</li><li>Visualization界面可以设置Legend的更多选项, 是否显示为一个表格, 表格是放在下方还是右方, 支持显示额外的聚合值如最大值最小值平均值当前值总值, 支持设置这些聚合值的小数位数.</li></ol><h1 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h1><p>告警在Grafana处可视化界面设置会比较简单, 可设置连续多少次指定的promQL查出的值不在指定的范围即触发报警, 告警通知的最佳搭配当然是slack channel.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近我对Prometheus刮目相看了, 服务加一行代码就能轻轻松松地监控起来服务的CPU使用率、内存、协程数、线程数、打开的文件描述符数量及软限制、重启次数等重要的基本指标, 配合Grafana建立了直观的图表, 对查问题很有帮助,
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="prometheus" scheme="https://imhanjm.com/tags/prometheus/"/>
    
      <category term="监控" scheme="https://imhanjm.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>深入理解ActiveMQ消息队列协议STMOP AMQP MQTT</title>
    <link href="https://imhanjm.com/2019/02/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ActiveMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8D%8F%E8%AE%AESTMOP%20AMQP%20MQTT/"/>
    <id>https://imhanjm.com/2019/02/07/深入理解ActiveMQ消息队列协议STMOP AMQP MQTT/</id>
    <published>2019-02-06T16:00:00.000Z</published>
    <updated>2019-02-14T07:39:39.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>AWS MQ是完全托管的 ActiveMQ 服务, 最近需要使用, 于是学习其文档, 实践其特性, 由于 ActiveMQ 支持非常丰富的协议, OpenWire amqp stomp mqtt, 所以也学习了各大协议的特性及其SDK.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本地开发最方便的方式当然是docker了, <a href="https://hub.docker.com/r/rmohr/activemq/" target="_blank" rel="noopener">rmohr/activemq</a> 文档比较好的且有aws支持的5.15.6版本的tag.</p><p>需要注意的是, 首先要根据其docker hub镜像文档上的几步操作, 将镜像中的默认配置文件复制到自定义的本机conf目录下 <code>/usr/local/activemq/conf</code>, 然后就快速地启动了一个默认配置的 ActiveMQ server</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> active mq</span></span><br><span class="line">docker run -itd --name activemq \</span><br><span class="line">-p 61616:61616 -p 8161:8161 -p 5672:5672 -p 61613:61613 -p 1883:1883 -p 61614:61614 \</span><br><span class="line">-v /usr/local/activemq/conf:/opt/activemq/conf \</span><br><span class="line">-v /usr/local/activemq/data:/opt/activemq/data \</span><br><span class="line">rmohr/activemq:5.15.6</span><br></pre></td></tr></table></figure><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h3 id="Advisory"><a href="#Advisory" class="headerlink" title="Advisory"></a>Advisory</h3><p>ActiveMQ可以将本身的一些事件投递到系统的消息队列, 如 queue/topic的创建, 没有消费者的queue/topic等. <a href="http://activemq.apache.org/advisory-message.html" target="_blank" rel="noopener">http://activemq.apache.org/advisory-message.html</a></p><p>这个特性对于监控MQ非常有用, 默认配置时关闭的, 需要在配置文件activemq.xml中打开.</p><h3 id="Wildcards"><a href="#Wildcards" class="headerlink" title="Wildcards"></a>Wildcards</h3><p>通配符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. 用于分割名字中的多个单词</span><br><span class="line">* 表示任一名字, 不包括点号(.)</span><br><span class="line">&gt; 表示任一名字, 包括点号(.), 用于表示前缀, &gt;符号后面不会再跟其他限制条件.</span><br></pre></td></tr></table></figure><p>通配符可以用在配置文件中表名作用范围, 也可以用于订阅时的destination名字, 这个功能很不错.</p><h3 id="Virtual-Topic"><a href="#Virtual-Topic" class="headerlink" title="Virtual Topic"></a>Virtual Topic</h3><p>所谓virtual topic 就是将一个正常的topic, 变成了多个queue. 如TopicA启用了Virtual topic, 则consumer可以去消费 Consumer.xxx.TopicA 这样模式的queue的消息. (<a href="http://activemq.apache.org/virtual-destinations.html" target="_blank" rel="noopener">http://activemq.apache.org/virtual-destinations.html</a>)</p><p>xxx对应类似NSQ中的Channel概念.</p><p>需要在activemq.xml中配置virtualDestinationInterceptor的范围 prefix及其他选项.</p><ul><li><p><code>name=&quot;&gt;&quot;</code> 表示所有的topic都启用virtualTopic功能. </p></li><li><p><code>prefix=&quot;Consumer.*.&quot;</code> 表示可以订阅的virtualTopic的pattern是Consumer..</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">destinationInterceptors</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">virtualDestinationInterceptor</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">virtualDestinations</span>&gt;</span> </span><br><span class="line">                    <span class="tag">&lt;<span class="name">virtualTopic</span> <span class="attr">name</span>=<span class="string">"&gt;"</span> <span class="attr">prefix</span>=<span class="string">"Consumer.*."</span> <span class="attr">selectorAware</span>=<span class="string">"false"</span>/&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;/<span class="name">virtualDestinations</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">virtualDestinationInterceptor</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">destinationInterceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Delay-amp-Schedule"><a href="#Delay-amp-Schedule" class="headerlink" title="Delay &amp; Schedule"></a>Delay &amp; Schedule</h3><p>ActiveMQ支持延时消息及定时消息, 在message header中带上如下字段即可, 其中AMQ_SCHEDULED_PERIOD的最大值是long的最大值, 所以可以设置延时很长时间.</p><table><thead><tr><th>Property name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>AMQ_SCHEDULED_DELAY</td><td>long</td><td>The time in milliseconds that a message will wait before being scheduled to be delivered by the broker</td></tr><tr><td>AMQ_SCHEDULED_PERIOD</td><td>long</td><td>The time in milliseconds to wait after the start time to wait before scheduling the message again</td></tr><tr><td>AMQ_SCHEDULED_REPEAT</td><td>int</td><td>The number of times to repeat scheduling a message for delivery</td></tr><tr><td>AMQ_SCHEDULED_CRON</td><td>String</td><td>Use a Cron entry to set the schedule</td></tr></tbody></table><h3 id="Dead-Letter-Queue"><a href="#Dead-Letter-Queue" class="headerlink" title="Dead Letter Queue"></a>Dead Letter Queue</h3><p>如果broker投递给消费者消息, 没有ACK或NACK, 则会触发重新投递, 投递超过一定次数则会进入死信队列, 默认只有一个公共的死信队列<strong>ActiveMQ.DLQ</strong>, 如果需要给topic分别设置死信队列, 则要在修改activemq.xml.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyMap</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Set the following policy on all queues using the '&gt;' wildcard --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policyEntry</span> <span class="attr">queue</span>=<span class="string">"&gt;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">              Use the prefix 'DLQ.' for the destination name, and make</span></span><br><span class="line"><span class="comment">              the DLQ a queue rather than a topic</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">individualDeadLetterStrategy</span> <span class="attr">queuePrefix</span>=<span class="string">"DLQ."</span> <span class="attr">useQueueForQueueMessages</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policyEntry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">policyEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">destinationPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认非持久化的topic不会进入到死信队列中, 如果需要, 则修改activemq.xml, 加入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">Tell the dead letter strategy to also place non-persisted messages </span></span><br><span class="line"><span class="comment">onto the dead-letter queue if they can't be delivered.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">deadLetterStrategy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">...</span>  <span class="attr">processNonPersistent</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">deadLetterStrategy</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h3 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h3><p>STOMP是Simple (or Streaming) Text Orientated Messaging Protocol 的缩写, 设计思路借鉴了HTTP, 有content-type, header, body, frame based, text based等类似HTTP的相关概念, 设计文档 &lt; <a href="https://stomp.github.io/stomp-specification-1.2.html&gt;" target="_blank" rel="noopener">https://stomp.github.io/stomp-specification-1.2.html&gt;</a>, 非常得简洁, 一页就讲完了.</p><h4 id="协议细节及特点"><a href="#协议细节及特点" class="headerlink" title="协议细节及特点:"></a>协议细节及特点:</h4><ol><li>对于重复的header key, 只有第一个有效.</li><li>服务端可以限制消息大小, header field数量, header长度.</li><li>一个client开多个subscriber时, 必须设置subscribe id.</li><li>NACK command 表示 requeue.</li><li>stomp有事务的概念, 消息从producer发出到broker确认收到算一个事务, broker投递到consumer ACK算一个事务, 事务具有原子性.</li><li>支持SSL.</li></ol><h4 id="ActiveMQ作为STOMP-server"><a href="#ActiveMQ作为STOMP-server" class="headerlink" title="ActiveMQ作为STOMP server"></a>ActiveMQ作为STOMP server</h4><ol><li><p>支持 v1.1版本的STMOP协议.</p></li><li><p>默认最大消息长度 <code>maxDataLength</code> 为 <code>104857600</code>, <code>maxFrameSize</code> 为 <code>MAX_LONG</code>.</p></li><li><p>通过 <code>destination</code> 名字前缀是<code>/queue/</code> 还是 <code>/topic</code>/ 来区分是 <code>queue</code> (生产消费模型)还是 <code>topic</code>(发布订阅模型). 真正的名字是去掉包括两个<code>/</code>符号的前缀后的.</p></li><li><p>发送默认不是持久化的, 需要在SEND时手动指定<code>persistent:true</code>的header以开启持久化.</p><p>订阅默认不是持久化的, 需要在SUBSCRIBE时手动指定<code>activemq.subscriptionName:订阅者名字</code>的header来开启持久化订阅.</p><p>很多特性都是靠STOMP header来处理的, ActiveMQ官方文档上有两节讲STOMP的header. <a href="http://activemq.apache.org/stomp.html#Stomp-StompExtensionsforJMSMessageSemantics" target="_blank" rel="noopener">http://activemq.apache.org/stomp.html#Stomp-StompExtensionsforJMSMessageSemantics</a></p></li></ol><h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p><a href="https://github.com/go-stomp/stomp" target="_blank" rel="noopener">https://github.com/go-stomp/stomp</a> 是目前star数最高的</p><ol><li>提了个PR <a href="https://github.com/go-stomp/stomp/pull/58" target="_blank" rel="noopener">https://github.com/go-stomp/stomp/pull/58</a></li><li>解决了个issue <a href="https://github.com/go-stomp/stomp/issues/47" target="_blank" rel="noopener">https://github.com/go-stomp/stomp/issues/47</a></li></ol><h4 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/go-stomp/stomp"</span></span><br><span class="line"><span class="string">"github.com/hanjm/log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">publisher(ctx, <span class="string">"/topic/stomp"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">Subscriber(ctx, <span class="string">"channel1"</span>, <span class="string">"Consumer.channel1.stomp"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">Subscriber(ctx, <span class="string">"channel2"</span>, <span class="string">"Consumer.channel2.stomp"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">Subscriber(ctx, <span class="string">"channel3"</span>, <span class="string">"/topic/stomp"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;()</span><br><span class="line">SignalsListen()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">publisher</span><span class="params">(ctx context.Context, destination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">conn, err := stomp.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:61613"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Disconnect()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">err = conn.Send(</span><br><span class="line">destination,  <span class="comment">// destination</span></span><br><span class="line"><span class="string">"text/plain"</span>, <span class="comment">// content-type</span></span><br><span class="line">[]<span class="keyword">byte</span>(<span class="string">"Test message #"</span>+strconv.Itoa(i)), stomp.SendOpt.Header(<span class="string">"persistent"</span>, <span class="string">"true"</span>)) <span class="comment">// body</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subscriber</span><span class="params">(ctx context.Context, clientID <span class="keyword">string</span>, destination <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">conn, err := stomp.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:61613"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Disconnect()</span><br><span class="line">sub, err := conn.Subscribe(destination, stomp.AckClientIndividual, stomp.SubscribeOpt.Id(clientID), stomp.SubscribeOpt.Header(<span class="string">"persistent"</span>, <span class="string">"true"</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">err := sub.Unsubscribe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(clientID, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> sub.C &#123;</span><br><span class="line"><span class="keyword">if</span> m.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Infof(<span class="string">"%s msg body:%s"</span>, clientID, m.Body)</span><br><span class="line"><span class="comment">//log.Infof("%s msg header:%s", clientID, *m.Header)</span></span><br><span class="line"><span class="comment">//log.Infof("%s msg content-type:%s", clientID, m.ContentType)</span></span><br><span class="line"><span class="comment">//log.Infof("%s msg destination:%s", clientID, m.Destination)</span></span><br><span class="line">m.Conn.Ack(m)</span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"close sub"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignalsListen</span><span class="params">()</span></span> &#123;</span><br><span class="line">sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(sigs, syscall.SIGQUIT,</span><br><span class="line">syscall.SIGTERM,</span><br><span class="line">syscall.SIGINT,</span><br><span class="line">syscall.SIGUSR1,</span><br><span class="line">syscall.SIGUSR2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &lt;-sigs &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT:</span><br><span class="line">log.Info(<span class="string">"service close"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h2><p>协议文档<a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a></p><p>翻译版文档<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html</a></p><h4 id="协议细节及特点-1"><a href="#协议细节及特点-1" class="headerlink" title="协议细节及特点:"></a>协议细节及特点:</h4><ol><li>transport支持TCP, 也支持WebSocket, 所以定位于IOT.</li><li>不支持生产消费模型, 只支持发布订阅模型.</li><li>用QOS来表示消息队列中的投递语义, QOS=0 表示至多发送一次, QOS=1表示至少发送一次, QOS=2表示精确地只发送一次.</li></ol><h4 id="ActiveMQ作为MQTT-server"><a href="#ActiveMQ作为MQTT-server" class="headerlink" title="ActiveMQ作为MQTT server"></a>ActiveMQ作为MQTT server</h4><ol><li>通配符不同, MQTT的 <code>/</code> <code>+</code> <code>#</code> 分别对应 ActiveMQ的<code>.</code> <code>*</code> <code>&gt;</code>.</li><li>QOS=0对应的是非持久化的topic, QOS=1或者QOS=2对应持久化的topic.</li></ol><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>协议文档: <a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html" target="_blank" rel="noopener">http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html</a></p><p>AMQP相比 stomp mqtt 就复杂得多, 毕竟名字就是高级消息队列(Advanced Message Queuing Protocol ). </p><h4 id="协议细节及特点-2"><a href="#协议细节及特点-2" class="headerlink" title="协议细节及特点:"></a>协议细节及特点:</h4><ol><li>AMQP有很多不同的概念, 如Link, Container, Node. 不看<a href="http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#doc-idp2176" target="_blank" rel="noopener">模型文档</a>的话就直接使用SDK的话会比较费劲. ContainerID对应ActiveMQ client ID,  LinkName对应ActiveMQ subscription name.</li><li></li></ol><h4 id="ActiveMQ作为AMQP-server"><a href="#ActiveMQ作为AMQP-server" class="headerlink" title="ActiveMQ作为AMQP server"></a>ActiveMQ作为AMQP server</h4><ol><li>使用1.0协议, 所以使用了0.9.1的2k star的sdk不能用.(<a href="https://github.com/streadway/amqp)" target="_blank" rel="noopener">https://github.com/streadway/amqp)</a>, 而且官方也认为没必要支持旧版本的协议.</li><li>默认最大消息长度 <code>maxDataLength</code> 为 <code>104857600</code>(100MB), <code>maxFrameSize</code> 为 <code>MAX_LONG</code>, consumer持有的未确认最大消息数量<code>prefetch</code>为1000, <code>producerCredit</code>为10000. 可通过连接的URI设定.</li><li>支持SSL.</li><li>通过 <code>destination</code> 名字前缀是<code>queue://</code> 还是 <code>topic://</code> 来区分是 <code>queue</code> (生产消费模型)还是 <code>topic</code>(发布订阅模型). 真正的名字是去掉包括两个<code>/</code>符号的前缀后的.</li></ol><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>分别使用</p><p>github.com/vcabbage/amqp 76star 13issue 5contributors<br>github.com/go-stomp/stomp 132star 3issue 14contributors<br>github.com/eclipse/paho.mqtt.golang 650star 20issue 34contributors</p><p>作为SDK, 分别测试了下pub sub 1KB大小的消息普通场景.</p><p>publish性能上, amqp=stomp&gt;mqtt, amqp和stomp差不多, 是mqtt的两倍多.<br>subscribe性能上, amqp比stomp快一点, mqtt则慢很多.</p><p>benchmark代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> all_bench</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/eclipse/paho.mqtt.golang"</span></span><br><span class="line"><span class="string">"github.com/go-stomp/stomp"</span></span><br><span class="line"><span class="string">"github.com/hanjm/log"</span></span><br><span class="line"><span class="string">"pack.ag/amqp"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msgData = bytes.Repeat([]<span class="keyword">byte</span>(<span class="string">"1"</span>), <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">stompDestination = <span class="string">"bench-stomp"</span></span><br><span class="line">amqpDestination  = <span class="string">"bench-amqp"</span></span><br><span class="line">mqttDestination  = <span class="string">"bench-mqtt"</span></span><br><span class="line">pubMsgCount      = <span class="number">20000</span></span><br><span class="line">subMsgCount      = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">m.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go test -bench Publish  -benchmem</span></span><br><span class="line"><span class="comment">// go test -bench Sub  -benchmem</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStompPublish</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">conn, err := stomp.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:61613"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Disconnect()</span><br><span class="line"></span><br><span class="line">b.N = pubMsgCount</span><br><span class="line">b.ReportAllocs()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">err = conn.Send(</span><br><span class="line">stompDestination, <span class="comment">// destination</span></span><br><span class="line"><span class="string">"text/plain"</span>,     <span class="comment">// content-type</span></span><br><span class="line">msgData) <span class="comment">// body</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAmqpPublish</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create client</span></span><br><span class="line">client, err := amqp.Dial(<span class="string">"amqp://127.0.0.1"</span>,</span><br><span class="line">amqp.ConnSASLPlain(<span class="string">"system"</span>, <span class="string">"manager"</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Dialing AMQP server:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Open a session</span></span><br><span class="line">session, err := client.NewSession()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Creating AMQP session:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">err = session.Close(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"failed to close session:%s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log.Info("session close")</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sender</span></span><br><span class="line">sender, err := session.NewSender(</span><br><span class="line">amqp.LinkTargetAddress(amqpDestination),</span><br><span class="line">amqp.LinkSourceDurability(amqp.DurabilityUnsettledState),</span><br><span class="line">amqp.LinkSourceExpiryPolicy(amqp.ExpiryNever),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Creating sender link:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">err := sender.Close(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"failed to close sender:%s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log.Infof("sender close")</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ctx := context.Background()</span><br><span class="line">msg := amqp.NewMessage(msgData)</span><br><span class="line"></span><br><span class="line">b.N = pubMsgCount</span><br><span class="line">b.ReportAllocs()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="comment">// Send message</span></span><br><span class="line">err = sender.Send(ctx, msg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Sending message:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMqttPublish</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">opt := mqtt.NewClientOptions().SetClientID(<span class="string">"pubClient"</span>).SetCleanSession(<span class="literal">false</span>)</span><br><span class="line">opt.AddBroker(<span class="string">"tcp://127.0.0.1:1883"</span>)</span><br><span class="line">client := mqtt.NewClient(opt)</span><br><span class="line">t := client.Connect()</span><br><span class="line">err := t.Error()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.Wait() &#123;</span><br><span class="line">err := t.Error()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">client.Disconnect(<span class="number">10000</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">b.N = pubMsgCount</span><br><span class="line">b.ReportAllocs()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">token := client.Publish(mqttDestination, <span class="number">2</span>, <span class="literal">true</span>, msgData)</span><br><span class="line">err := token.Error()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStompSubscriber</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">conn, err := stomp.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:61613"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">clientID := <span class="string">"1"</span></span><br><span class="line"><span class="comment">//defer conn.Disconnect()</span></span><br><span class="line">sub, err := conn.Subscribe(stompDestination, stomp.AckClientIndividual, stomp.SubscribeOpt.Id(clientID))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//defer func() &#123;</span></span><br><span class="line"><span class="comment">//err := sub.Unsubscribe()</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//log.Fatal(clientID, err)</span></span><br><span class="line"><span class="comment">//return</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return</span></span><br><span class="line"><span class="comment">//&#125;()</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">b.N = subMsgCount</span><br><span class="line">b.ReportAllocs()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">defer</span> b.StopTimer()</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt64(&amp;i) &gt;= <span class="keyword">int64</span>(b.N) &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//log.Info("close")</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-sub.C:</span><br><span class="line"><span class="keyword">if</span> m.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(m.Err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.Conn.Ack(m)</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt64(&amp;i) &gt; <span class="keyword">int64</span>(b.N) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAmqpSubscriber</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create client</span></span><br><span class="line">client, err := amqp.Dial(<span class="string">"amqp://127.0.0.1"</span>,</span><br><span class="line">amqp.ConnSASLPlain(<span class="string">"system"</span>, <span class="string">"manager"</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Dialing AMQP server:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//defer client.Close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Open a session</span></span><br><span class="line">session, err := client.NewSession()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Creating AMQP session:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clientID := <span class="string">"1"</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">err := session.Close(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"%s failed to close session:%s"</span>, clientID, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log.Errorf("%s session close", clientID)</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Continuously read messages</span></span><br><span class="line"><span class="comment">// Create a receiver</span></span><br><span class="line">receiver, err := session.NewReceiver(</span><br><span class="line">amqp.LinkSourceAddress(amqpDestination),</span><br><span class="line">amqp.LinkCredit(<span class="number">10</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Creating receiver link:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">err := receiver.Close(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(<span class="string">"%s failed to close receiver:%s"</span>, clientID, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log.Errorf("%s receiver close", clientID)</span></span><br><span class="line">&#125;()</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">b.N = subMsgCount</span><br><span class="line">b.ReportAllocs()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">defer</span> b.StopTimer()</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt64(&amp;i) &gt;= <span class="keyword">int64</span>(b.N) &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// Receive next message</span></span><br><span class="line">msg, err := receiver.Receive(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == context.Canceled &#123;</span><br><span class="line">log.Infof(<span class="string">"Reading message from AMQP:%s"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">log.Errorf(<span class="string">"Reading message from AMQP:%s"</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//log.Infof("%s msg body:%s value:%T %s", clientID, msg.GetData(), msg.Value, msg.Value)</span></span><br><span class="line"><span class="comment">// Accept message</span></span><br><span class="line">msg.Accept()</span><br><span class="line">atomic.AddInt64(&amp;i, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt64(&amp;i) &gt; <span class="keyword">int64</span>(b.N) &#123;</span><br><span class="line"><span class="comment">//log.Info("return")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMqttSubscriber</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">opt := mqtt.NewClientOptions().SetClientID(<span class="string">"subClient"</span>).SetCleanSession(<span class="literal">false</span>)</span><br><span class="line">opt.AddBroker(<span class="string">"tcp://127.0.0.1:1883"</span>)</span><br><span class="line">client := mqtt.NewClient(opt)</span><br><span class="line">t := client.Connect()</span><br><span class="line"><span class="keyword">if</span> t.Wait() &#123;</span><br><span class="line">err := t.Error()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">client.Disconnect(<span class="number">1000</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">b.N = subMsgCount</span><br><span class="line">b.ReportAllocs()</span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">defer</span> b.StopTimer()</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> time.Tick(time.Second) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt64(&amp;i) &gt;= <span class="keyword">int64</span>(b.N) &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">client.Subscribe(mqttDestination, <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">(c mqtt.Client, m mqtt.Message)</span></span> &#123;</span><br><span class="line"><span class="comment">//log.Infof("%s msg body:%s", "1", m.Payload())</span></span><br><span class="line">m.Ack()</span><br><span class="line">atomic.AddInt64(&amp;i, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> atomic.LoadInt64(&amp;i) &gt; <span class="keyword">int64</span>(b.N) &#123;</span><br><span class="line"><span class="comment">//log.Info("return")</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">log.Info(<span class="string">"close sub"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些细节行为"><a href="#一些细节行为" class="headerlink" title="一些细节行为"></a>一些细节行为</h1><p><a href="http://activemq.apache.org/using-apache-activemq.html" target="_blank" rel="noopener">官方的FAQ</a>里面写了一些实现的细节</p><ol><li>如果producer比较快而consumer比较慢的话, ActiveMQ的流量控制功能使得producer阻塞. <a href="http://activemq.apache.org/what-happens-with-a-fast-producer-and-slow-consumer.html" target="_blank" rel="noopener">http://activemq.apache.org/what-happens-with-a-fast-producer-and-slow-consumer.html</a></li><li>不支持消费者拿到消息之后Requeue, 即不支持像NSQ那样的消费者出现业务逻辑错误后重试.<a href="http://activemq.apache.org/how-do-i-unack-the-message-with-stomp.html" target="_blank" rel="noopener">http://activemq.apache.org/how-do-i-unack-the-message-with-stomp.html</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;AWS MQ是完全托管的 ActiveMQ 服务, 最近需要使用, 于是学习其文档, 实践其特性, 由于 ActiveMQ
        
      
    
    </summary>
    
    
      <category term="activemq" scheme="https://imhanjm.com/tags/activemq/"/>
    
      <category term="mq" scheme="https://imhanjm.com/tags/mq/"/>
    
      <category term="messageQueue" scheme="https://imhanjm.com/tags/messageQueue/"/>
    
      <category term="pubsub" scheme="https://imhanjm.com/tags/pubsub/"/>
    
  </entry>
  
  <entry>
    <title>Macos Docker container连接宿主机172.17.0.1的办法</title>
    <link href="https://imhanjm.com/2018/12/16/macos%20docker%20container%E8%BF%9E%E6%8E%A5%E5%AE%BF%E4%B8%BB%E6%9C%BA172.17.0.1%E7%9A%84%E5%8A%9E%E6%B3%95/"/>
    <id>https://imhanjm.com/2018/12/16/macos docker container连接宿主机172.17.0.1的办法/</id>
    <published>2018-12-15T16:00:00.000Z</published>
    <updated>2018-12-16T05:27:03.173Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux docker container里面, 如果想访问宿主机上的服务, 用 172.17.0.1 这个host即可.</p><p>今天在Mac上的 dockercontainer里面启动一个服务, 这个服务需要连我主机上的MySQL, 用 172.17.0.1 是访问不了的, Connection refused.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@d99939cc53fc:/tmp# curl 172.17.0.1:3306</span><br><span class="line">curl: (7) Failed to connect to 172.17.0.1 port 3306: Connection refused</span><br></pre></td></tr></table></figure><p>但是看网络结构, 和Linux的一样, 也是在172.17段下的.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@d99939cc53fc:/tmp# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">6: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>不得其解, Google之, 发现有个隐藏奥秘, <a href="https://stackoverflow.com/questions/38504890/docker-for-mac-1-12-0-how-to-connect-to-host-from-container" target="_blank" rel="noopener">https://stackoverflow.com/questions/38504890/docker-for-mac-1-12-0-how-to-connect-to-host-from-container</a> 问题下有人在 <em>Docker Community Edition 17.06.0-ce-mac18, 2017-06-28</em> 的<a href="https://docs.docker.com/docker-for-mac/release-notes/" target="_blank" rel="noopener">release notes</a>中发现有 </p><blockquote><p>Add an experimental DNS name for the host: docker.for.mac.localhost</p></blockquote><p>这样一条更新日志. </p><p>页面搜索<code>docker.for.mac.localhost</code>, 发现在 <em>Docker Community Edition 17.12.0-ce-mac46 2018-01-09</em> 的 release notes中发现有一条相关的更新日志</p><blockquote><ul><li>DNS name <code>docker.for.mac.host.internal</code> should be used instead of <code>docker.for.mac.localhost</code> (still valid) for host resolution from containers, since since there is an RFC banning the use of subdomains of localhost. See <a href="https://tools.ietf.org/html/draft-west-let-localhost-be-localhost-06" target="_blank" rel="noopener">https://tools.ietf.org/html/draft-west-let-localhost-be-localhost-06</a>.</li></ul></blockquote><p>所以, 结论就是在 container 中应该用 <code>docker.for.mac.host.internal</code> 来访问宿主机.</p><p>于是用curl看一下端口通不通, 果然通.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@d99939cc53fc:/tmp# curl docker.for.mac.host.internal:3306</span><br><span class="line">5.7.21Bf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在Linux docker container里面, 如果想访问宿主机上的服务, 用 172.17.0.1 这个host即可.&lt;/p&gt;
&lt;p&gt;今天在Mac上的 dockercontainer里面启动一个服务, 这个服务需要连我主机上的MySQL, 用 172.17.0.1
        
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://imhanjm.com/tags/Docker/"/>
    
      <category term="172.17.0.1" scheme="https://imhanjm.com/tags/172-17-0-1/"/>
    
      <category term="docker for mac" scheme="https://imhanjm.com/tags/docker-for-mac/"/>
    
  </entry>
  
  <entry>
    <title>Nginx With gRPC编译安装</title>
    <link href="https://imhanjm.com/2018/12/15/Nginx%20with%20gRPC%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
    <id>https://imhanjm.com/2018/12/15/Nginx with gRPC编译安装/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2018-12-16T04:23:03.227Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过nginx HTTP2编译安装的文章, 最近想探索下nginx with gRPC support, 所以更新一下.</p><p>yum apt等包管理系统安装的软件有时候比较旧, 导致一些莫名其妙的问题. 最近在给Nginx加HTTP/2模块中, 编译时加上了<code>--with-http_v2_module</code>参数, 但Chrome请求发现还是不是http2, 后面发现是OpenSSL版本太低. 踩过这一坑后, 感觉Linux下部分软件最好还是自己编译安装比较妥, 如果编译过程出错, 搜下错误信息, 一般是基础依赖没有安装, 很好解决.</p><p>官方的源码编译指南<br><a href="https://nginx.org/en/docs/configure.html" target="_blank" rel="noopener">https://nginx.org/en/docs/configure.html</a><br><a href="https://nginx.org/en/docs/http/ngx_http_v2_module.html" target="_blank" rel="noopener">https://nginx.org/en/docs/http/ngx_http_v2_module.html</a> (这里写了需要OpenSSL1.0.2以上版本), 很多选项都有合适的默认值, 比如–prefix=/usr/local/nginx, 所以只需要指定自己需要的字段</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--user=www-data // 习惯将web相关的服务以www-data用户运行, 如没有此用户可以创建一个也可不加此项按默认nobody用户</span><br><span class="line">--group=www-data</span><br><span class="line">--with-http_v2_module // 默认选项不带http2</span><br><span class="line">--with-http_ssl_module // 默认选项不带ssl, 上http2必须要上ssl的</span><br><span class="line">--with-stream // https://nginx.org/en/docs/stream/ngx_stream_core_module.html</span><br><span class="line">--with-openssl // 指定OpenSSL</span><br><span class="line">--with-pcre=./pcre-8.40 // 需要(version 4.4 — 8.40)的pcre,注意Nginx不支持pcre2</span><br><span class="line">--with-pcre-jit // 打开pcre JIT支持</span><br><span class="line">--with-zlib=./zlib-1.2.11 // 需要(version 1.1.3 — 1.2.11)的zlib以支持gzip</span><br></pre></td></tr></table></figure><p>1.<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">官网下载Nginx包</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">wget https://nginx.org/download/nginx-1.14.2.tar.gz</span><br><span class="line">tar -zxf nginx-1.14.2.tar.gz</span><br><span class="line">cd nginx-1.14.2</span><br></pre></td></tr></table></figure><p>2.[官网下载OpenSSL 1.0.2以上版本].<a href="https://github.com/openssl/openssl/releases" target="_blank" rel="noopener">https://github.com/openssl/openssl/releases</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nginx-1.14.2</span><br><span class="line">wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_0e.tar.gz</span><br><span class="line">tar -zxf OpenSSL_1_1_0e.tar.gz</span><br></pre></td></tr></table></figure><p>2.<a href="https://ftp.pcre.org/pub/pcre/" target="_blank" rel="noopener">官网下载pcre</a></p><p>注意Nginx不支持pcre2,下载pcre最新版即可. 解压到Nginx解压的目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nginx-1.14.2</span><br><span class="line">wget https://ftp.pcre.org/pub/pcre/pcre-8.40.tar.gz</span><br><span class="line">tar -zxf pcre-8.40.tar.gz</span><br></pre></td></tr></table></figure><p>4.<a href="http://zlib.net/" target="_blank" rel="noopener">官网下载zlib</a>(version 1.1.3 — 1.2.11)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nginx-1.14.2</span><br><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxf zlib-1.2.11.tar.gz</span><br></pre></td></tr></table></figure><p>5.编译并安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--user=nginx \</span><br><span class="line">--group=nginx \</span><br><span class="line">--conf-path=/etc/nginx/nginx.conf \</span><br><span class="line">--with-http_v2_module \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-stream \</span><br><span class="line">--with-openssl=./openssl-OpenSSL_1_1_0e \</span><br><span class="line">--with-pcre=./pcre-8.40 --with-pcre-jit \</span><br><span class="line">--with-zlib=./zlib-1.2.11</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>6.为了方便操作,软链/usr/local/nginx/sbin/nginx到/usr/local/bin</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/local/nginx/sbin/nginx /usr/local/bin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前写过nginx HTTP2编译安装的文章, 最近想探索下nginx with gRPC support, 所以更新一下.&lt;/p&gt;
&lt;p&gt;yum apt等包管理系统安装的软件有时候比较旧, 导致一些莫名其妙的问题. 最近在给Nginx加HTTP/2模块中,
        
      
    
    </summary>
    
    
      <category term="Nginx" scheme="https://imhanjm.com/tags/Nginx/"/>
    
      <category term="HTTP2" scheme="https://imhanjm.com/tags/HTTP2/"/>
    
      <category term="GRPC" scheme="https://imhanjm.com/tags/GRPC/"/>
    
  </entry>
  
  <entry>
    <title>Go sql.Driver的mysql Driver 中的一个有意思的行为</title>
    <link href="https://imhanjm.com/2018/11/29/go%20sql.Driver%E7%9A%84mysql%20driver%20%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E8%A1%8C%E4%B8%BA/"/>
    <id>https://imhanjm.com/2018/11/29/go sql.Driver的mysql driver 中的一个有意思的行为/</id>
    <published>2018-11-28T16:00:00.000Z</published>
    <updated>2018-12-15T12:10:25.276Z</updated>
    
    <content type="html"><![CDATA[<p>如果参数中没有参数, 则直接query.<br>如果sql中有参数, 且打开了InterpolateParams开关, 那么就客户端直接拼参数到SQL里, 不需要prepare直接query.<br>如果sql中有参数, 且没有打开InterpolateParams(默认设置), 且带参数, 就会走先prepare再发query参数两步.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">github.com/<span class="keyword">go</span>-sql-driver/mysql/connection.<span class="keyword">go</span>:<span class="number">370</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *mysqlConn)</span> <span class="title">query</span><span class="params">(query <span class="keyword">string</span>, args []driver.Value)</span> <span class="params">(*textRows, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !mc.cfg.InterpolateParams &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrSkip</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try client-side prepare to reduce roundtrip</span></span><br><span class="line">prepared, err := mc.interpolateParams(query, args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">query = prepared</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send command</span></span><br><span class="line">err := mc.writeCommandPacketStr(comQuery, query)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Read Result</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>后续再补篇文章详细写写sql.Driver</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;如果参数中没有参数, 则直接query.&lt;br&gt;如果sql中有参数, 且打开了InterpolateParams开关, 那么就客户端直接拼参数到SQL里, 不需要prepare直接query.&lt;br&gt;如果sql中有参数,
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="mysql" scheme="https://imhanjm.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>学习Influxdb</title>
    <link href="https://imhanjm.com/2018/11/18/%E5%AD%A6%E4%B9%A0influxdb/"/>
    <id>https://imhanjm.com/2018/11/18/学习influxdb/</id>
    <published>2018-11-17T16:00:00.000Z</published>
    <updated>2018-12-15T12:12:49.160Z</updated>
    
    <content type="html"><![CDATA[<p>最近要实现接口监控, 准备用主流的时序数据库influxdb.</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>influxdb的库也 database, 概念和mysql一样<br>influxdb的表叫 MEASUREMENTS, 意义更贴切, 测量的复数形式.<br>influxdb的一行数据叫 point, 就像做物理实验的打点, 每个点有其值和属性<br>influxdb的字段分类为 tag 和 field, field就是值, tag是其属性. 拿接口来说, 字段有 service_name, instance_id, method, handler_name, method, request_url, response_code, content_length, response_size, duration. 显然, 前面7个字段是tag, 特点是一般不是数值变量, 可枚举的, 所以influxdb对tag加了索引. 后面3个是field, 是数值变量, 是范围变化的, 不需要加索引.</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>对于插入数据, influxdb同时提供了单条和批量插入的API. 开始不知道有批量方式, 来一条插一条, influxdb CPU巨高. 后面在官网文档找到了办法, 改用批量插入, 大大降低了CPU占用, 官方推荐是5k~1w条数据一批.</p><blockquote><p><a href="https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#batch" target="_blank" rel="noopener">https://docs.influxdata.com/influxdb/v1.7/concepts/glossary/#batch</a></p><p>InfluxData recommends batch sizes of 5,000-10,000 points,<br>although different use cases may be better served by significantly smaller or larger batches.</p></blockquote><p>influxdb同时提供了HTTP接口和UDP接口. UDP的好处在于减少了HTTP头部的开销, 性能更好</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li><p>库</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 创建数据库</span><br><span class="line">CREATE DATABASE "db_name"</span><br><span class="line"><span class="meta">#</span> 显示所有数据库</span><br><span class="line">SHOW DATABASES</span><br><span class="line"><span class="meta">#</span> 删除数据库</span><br><span class="line">DROP DATABASE "db_name"</span><br><span class="line"><span class="meta">#</span> 使用数据库</span><br><span class="line">USE mydb</span><br></pre></td></tr></table></figure></li><li><p>表</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 显示该数据库中的表</span><br><span class="line">SHOW MEASUREMENTS</span><br><span class="line"><span class="meta">#</span> 创建表, 插入数据时会自动创建</span><br><span class="line"><span class="meta">#</span> 删除表</span><br><span class="line">DROP MEASUREMENT "measurementName"</span><br></pre></td></tr></table></figure></li><li><p>查看数据保留策略 retention polices</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SHOW RETENTION POLICIES ON "testDB"</span><br></pre></td></tr></table></figure></li><li><p>创建新的Retention Policies并设置为默认值</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> DURATION 保留多少天</span><br><span class="line"><span class="meta">#</span> REPLICATION 副本数</span><br><span class="line">CREATE RETENTION POLICY "rp_name" ON "db_name" DURATION 30d REPLICATION 1 DEFAULT</span><br></pre></td></tr></table></figure></li></ol><h2 id="连续查询"><a href="#连续查询" class="headerlink" title="连续查询"></a>连续查询</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 创建一个连续查询, 每10秒计算一个接口响应耗时平均值到新表</span><br><span class="line">CREATE CONTINUOUS QUERY cq_http_handler_stats_duration ON statsdb BEGIN SELECT mean("duration") INTO http_handler_stats_average_duraion_10s FROM http_handler_stats GROUP BY time(10s) END</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果成功创建, 那么过了第一个周期后, SHOW MEASUREMENTS 能看到多了一张表</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 显示创建的连续查询</span><br><span class="line">SHOW CONTINUOUS QUERIES</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除</span><br><span class="line">DROP CONTINUOUS QUERY cq_http_handler_stats_duration ON statsdb</span><br></pre></td></tr></table></figure><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>grafana 是 influxdb 的良好伴侣, 写个query语句就能得到很炫酷的图形. 比如接口请求量图表按handler_name, response_code, time(10s) group by就得到了.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近要实现接口监控, 准备用主流的时序数据库influxdb.&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;influxdb的库也 database,
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="influxdb" scheme="https://imhanjm.com/tags/influxdb/"/>
    
  </entry>
  
  <entry>
    <title>GRPC文档阅读心得</title>
    <link href="https://imhanjm.com/2018/10/06/GRPC%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E5%BF%83%E5%BE%97/"/>
    <id>https://imhanjm.com/2018/10/06/GRPC文档阅读心得/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-07T15:34:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要是两个文档, grpc repo的文档 <a href="https://github.com/grpc/grpc/tree/master/doc" target="_blank" rel="noopener">https://github.com/grpc/grpc/tree/master/doc</a> , grpc-go repo的文档 <a href="https://github.com/grpc/grpc-go/tree/master/Documentation" target="_blank" rel="noopener">https://github.com/grpc/grpc-go/tree/master/Documentation</a>.</p><h1 id="grpc-go-文档"><a href="#grpc-go-文档" class="headerlink" title="grpc-go 文档"></a>grpc-go 文档</h1><hr><h3 id="gRPC-Server-Reflection-Tutorial"><a href="#gRPC-Server-Reflection-Tutorial" class="headerlink" title="gRPC Server Reflection Tutorial"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/server-reflection-tutorial.md" target="_blank" rel="noopener">gRPC Server Reflection Tutorial</a></h3><p>在代码中<code>import &quot;google.golang.org/grpc/reflection&quot;</code>包, 然后加一行代码<code>reflection.Register(s)</code>, 就可以启用 server reflection. 就可以用grpc_cli去进行获得服务列表, 方法列表, message结构体定义了. reflection.Register(s)实际上是注册了一个特殊的service, 它能列出server中已注册的服务和方法等信息.</p><h2 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/compression.md" target="_blank" rel="noopener">Compression</a></h2><p>用 <code>encoding.RegisterCompressor</code>方法取注册一个压缩器, 启用了压缩的话, 服务端和客户端双方都要进行同样的处理, 服务端在newServer时要带上compressor的serverOption, 客户端在dail的时候要带上WithDefaultCallOptions的DialOption, DialOption加上压缩解压的处理, 不然会得到一个 <code>Internal error</code>, 和HTTP方式一样, 压缩类型体现在content-type的header上.</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/concurrency.md" target="_blank" rel="noopener">Concurrency</a></h2><p>Dial得到的ClientConn是并发安全.<br>stream的读写不是并发安全的, sendMsg或RecvMsg不能在多个goroutine中并发地调用,但可以分别在两个goroutine中处理send和Recv.</p><h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/encoding.md" target="_blank" rel="noopener">Encoding</a></h2><h3 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h3><p>自定义消息编码解码, 注册一个实现 <code>Codec</code> 接口的对象即可, 然后在Dial或Call时带上<code>grpc.CallContentSubtype</code>这个CallOption, 这样就可以自动处理这个带这个content-type的请求. 默认为 proto</p><h3 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h3><p>自定义压缩解压缩, 注册一个实现 <code>Compressor</code>接口的对象即可, 然后在Dial或Call时带上<code>grpc.UseCompressor</code>这个CallOption.</p><h2 id="Mocking-Service-for-gRPC"><a href="#Mocking-Service-for-gRPC" class="headerlink" title="[Mocking Service for gRPC"></a>[Mocking Service for gRPC</h2><p>](<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/gomock-example.md" target="_blank" rel="noopener">https://github.com/grpc/grpc-go/blob/master/Documentation/gomock-example.md</a>)</p><p>主要讲如何在单元测试中mock, 用gomock命令行生成实现xx接口的代码, 没什么特别的</p><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="[Authentication"></a>[Authentication</h2><p>](<a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md" target="_blank" rel="noopener">https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-auth-support.md</a>)</p><p>主要讲如何进行身份验证, 没什么特别的</p><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md" target="_blank" rel="noopener">Metadata</a></h2><p>metadata类似HTTP1中的header, 数据结构都是一样的<code>type MD map[string][]string</code>,<br>key都是大小写不敏感的, 但实现规范和HTTP1不一样, HTTP1是按单词之间用连字符”-“分隔, 每个单词第一个字母大写这样的规范来的, 处理起来消耗更大, 而metadata是全转为小写, 实际使用过程中, 提前规范化key能提高不必要的<code>strings.ToLower</code>调用.<br>用-bin结尾的来传递二进制数据.</p><p>服务端handler用<code>metadata.FromIncomingContext(ctx)</code>拿到metadata, 客户端用<code>metadata.AppendToOutgoingContext</code>来附加kv到ctx中.</p><p>如果服务端handler又想附加一些信息返回client, 那么就要通过header和trailer传递, 类似responseHeader.<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SomeRPC</span><span class="params">(ctx context.Context, in *pb.someRequest)</span> <span class="params">(*pb.someResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// create and send header</span></span><br><span class="line">    header := metadata.Pairs(<span class="string">"header-key"</span>, <span class="string">"val"</span>)</span><br><span class="line">    grpc.SendHeader(ctx, header)</span><br><span class="line">    <span class="comment">// create and set trailer</span></span><br><span class="line">    trailer := metadata.Pairs(<span class="string">"trailer-key"</span>, <span class="string">"val"</span>)</span><br><span class="line">    grpc.SetTrailer(ctx, trailer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后客户端在调用的时候传要保存的header和trailler的指针到CallOption中, 调用完后指针指向的metadata map就有数据了, 坦率地讲, 我觉得这样处理很麻烦.<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header, trailer metadata.MD <span class="comment">// variable to store header and trailer</span></span><br><span class="line">r, err := client.SomeRPC(</span><br><span class="line">    ctx,</span><br><span class="line">    someRequest,</span><br><span class="line">    grpc.Header(&amp;header),    <span class="comment">// will retrieve header</span></span><br><span class="line">    grpc.Trailer(&amp;trailer),  <span class="comment">// will retrieve trailer</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something with header and trailer</span></span><br></pre></td></tr></table></figure></p><h2 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/keepalive.md" target="_blank" rel="noopener">Keepalive</a></h2><p>gRPC会定时发http2 ping帧来判断连接是否挂掉, 如果ping没有在一定时期内ack, 那么连接会被close.</p><h2 id="Log-Levels"><a href="#Log-Levels" class="headerlink" title="Log Levels"></a><a href="https://github.com/grpc/grpc-go/blob/master/Documentation/log_levels.md" target="_blank" rel="noopener">Log Levels</a></h2><p>grpc-go包默认用gpclog包打日志, grpclog包默认是用多个*log.Logger来实现日志级别, 默认输出到stderr, 对于生产环境, 肯定要集成到自己的日志流里去, 接口是个好东西, grpclog包允许setLog, 实现grpclog.LoggerV2接口即可.</p><h3 id="info日志包括"><a href="#info日志包括" class="headerlink" title="info日志包括:"></a>info日志包括:</h3><p>grpclog里的info是为了debug</p><ul><li>DNS 收到了更新</li><li>负载均衡器 更新了选择的目标</li><li>重要的grpc 状态变更<h3 id="warn日志包括"><a href="#warn日志包括" class="headerlink" title="warn日志包括:"></a>warn日志包括:</h3>warning日志是出现了一些错误, 但还不至于panic.</li><li>DNS无法解析给定的target</li><li>连接server时出错</li><li>连接丢失或中断<h3 id="error日志包括"><a href="#error日志包括" class="headerlink" title="error日志包括:"></a>error日志包括:</h3>grpc内部有些error不是用户发起的函数调用, 所以无法返回error给调用者, 只能内部自己打error日志</li><li>函数签名没有error, 但调用方传了个错误的参数过来.  </li><li>内部错误.<h3 id="Fatal日志"><a href="#Fatal日志" class="headerlink" title="Fatal日志:"></a>Fatal日志:</h3>fatal日志是出现了不可恢复的内部错误, 要panic.</li></ul><h1 id="grpc-文档"><a href="#grpc-文档" class="headerlink" title="grpc 文档"></a>grpc 文档</h1><hr><p>之前一直有个误区, 多个连接比单个连接要快, 看了 <a href="https://github.com/grpc/grpc-go/issues/1512" target="_blank" rel="noopener">grpc-go issues1</a>、<a href="https://github.com/grpc/grpc-go/issues/682" target="_blank" rel="noopener">grpc-go issues2</a> 以及 <a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">HTTP2文档</a> 才发现, 由于HTTP2有多路复用的特性, 对于同一个sever, 只需要维护一个连接就好了, 没有必要用多个连接去并行复用数据流. 连接数量减少对提升 HTTPS 部署的性能来说是一项特别重要的功能：可以减少开销较大的 TLS 连接数、提升会话重用率，以及从整体上减少所需的客户端和服务器资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;主要是两个文档, grpc repo的文档 &lt;a href=&quot;https://github.com/grpc/grpc/tree/master/doc&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="GRPC" scheme="https://imhanjm.com/tags/GRPC/"/>
    
      <category term="grpc-go" scheme="https://imhanjm.com/tags/grpc-go/"/>
    
  </entry>
  
  <entry>
    <title>Go如何优雅地错误处理(Error Handling and Go 1)</title>
    <link href="https://imhanjm.com/2018/07/08/Go%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86(Error%20handling%20and%20Go%201)/"/>
    <id>https://imhanjm.com/2018/07/08/Go如何优雅地错误处理(Error handling and Go 1)/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-09-01T00:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go的错误处理一直被吐槽太繁琐, 作为主要用GO的攻城狮, 经常写 <code>if err!=nil</code>, 但是如果想偷懒, 少带了上下文信息, 直接写 <code>if err!=nil { return err}</code> 或者 <code>fmt.Errorf</code> 携带的上下文信息太少了的话, 看到错误日志也会一脸懵逼, 难以定位问题.<br>官方在 2011 年就发过一篇博客教大家如何在Go中处理error <a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a> , error 是一个内建的 interface, 鼓励大家用好自定义错误类型, 常用的范式有三种:</p><ul><li>一是用 <code>errors.New(str string)</code> 定义错误常量, 让调用方去判断返回的 <code>err</code> 是否等于这个常量, 来进行区分处理;</li><li>二是用 <code>fmt.Errorf(fmt string, args... interface{})</code> 增加一些上下文信息, 用文字的方式告诉调用方哪里出错了, 让调用方打错误日志出来;</li><li>三是自定义 struct type , 实现 error 接口, 调用方用类型断言转成特定的 struct type , 拿到更结构化的错误信息.</li></ul><p>我最开始最常用的做法是, fmt.Errorf 时写上 此函数函数名、调用出错的函数名、参数是什么、err , 代码十分啰嗦, 而且通常打日志是在上层函数打的, 看到错误日志还需要用函数名去代码中搜索看看在哪里出错. 业务代码调用层级一多,非常麻烦. 很多情况下我既想带上下文信息, 又想在上层调用方取得最里层出错的函数返回的error常量或自定义的 struct type, 最好还能自动带上行号函数名信息, 减少每次写 fmt.Errof 的手动写上函数名的痛苦. 于是开始在 github 找包, star 数最高的是 <code>pkg/errors</code> 、<code>juju/errors</code>.</p><ul><li><code>pkg/errors</code> 解决了一些问题, 核心函数是 Wrapf 和 Cause: Wrapf包装错误附加上下文信息并带上调用栈, 但是每次去包装错误的时候都去取一次调用栈, 完全没有必要啊, 因为最早出错的函数里就能拿到完整的调用栈的, 并且调用栈打出来的信息也不好看, 而且通常HTTP服务会用框架, 用了框架的话调用栈就会肿起来, 这些框架的固定调用栈信息打印出来毫无帮助. Cause 去递归拿到最里层的 error, 用于和error常量比较或类型断言成自定义 struct type.</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrapf returns an error annotating err with a stack trace</span></span><br><span class="line"><span class="comment">// at the point Wrapf is call, and the format specifier.</span></span><br><span class="line"><span class="comment">// If err is nil, Wrapf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrapf</span><span class="params">(err error, format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = &amp;withMessage&#123;</span><br><span class="line">cause: err,</span><br><span class="line">msg:   fmt.Sprintf(format, args...),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">err,</span><br><span class="line">callers(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cause returns the underlying cause of the error, if possible.</span></span><br><span class="line"><span class="comment">// An error value has a cause if it implements the following</span></span><br><span class="line"><span class="comment">// interface:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     type causer interface &#123;</span></span><br><span class="line"><span class="comment">//            Cause() error</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the error does not implement Cause, the original error will</span></span><br><span class="line"><span class="comment">// be returned. If the error is nil, nil will be returned without further</span></span><br><span class="line"><span class="comment">// investigation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> causer <span class="keyword">interface</span> &#123;</span><br><span class="line">Cause() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">cause, ok := err.(causer)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">err = cause.Cause()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>juju/errors</code> API非常复杂, 包装的error的函数就有三个 <code>func Annotatef(other error, format string, args ...interface{}) error</code> 、<code>func Maskf(other error, format string, args ...interface{}) error</code> 、 <code>func Wrapf(other, newDescriptive error, format string, args ...interface{}) error</code> … , 每次包装时都会SetLocation, 消耗更大, 即时有时不需要打印error string 只需要判断, 它也去用runtime.Caller去拿文件名, 行号; 调用栈打出来的信息也不好看.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SetLocation records the source location of the error at callDepth stack</span><br><span class="line">// frames above the call.</span><br><span class="line">func (e *Err) SetLocation(callDepth int) &#123;</span><br><span class="line">_, file, line, _ := runtime.Caller(callDepth + 1)</span><br><span class="line">e.file = trimGoPath(file)</span><br><span class="line">e.line = line</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上包不满足要求, 只能造轮子了. 两个思想. API要设计的简单, 调用栈要好看 <a href="https://github.com/hanjm/errors" target="_blank" rel="noopener">https://github.com/hanjm/errors</a></p><ul><li>API简单: 定义error常量只有 <code>errors.New</code> 函数, 兼容标准库的函数, 兼容很重要; 包装error的只有 <code>errors.Errorf</code> 函数, 只在最早出错的时候取调用栈, 调用方再包装时无需取调用栈, 此时只需要pc, 不需要这时就把文件名行号取出来; 取最里层的 error 只有 <code>errors.GetInnerMost</code>, 用于和 error 常量比较或类型断言成自定义 struct type分类处理.</li><li>调用栈好看: 去掉标准包的调用栈, 去掉框架固定的调用栈信息(通常是github.com的包), 只保留业务逻辑的调用栈. 按[ 文件名:行号 函数名:message]分行格式化输出, 把调用栈和附加的message对应起来. (第一版格式是[文件名:行号 函数名:message], 没有空格, 后面有个同事说在Goland IDE里看panic信息时可以点击定位到源码, 你的包能不能加这个功能, 所以去研究了下, 写了几个print的demo试了下发现如果输出中的文件名前后带空格的话, intellij IDE会自动识别输出中的文件名变成超链接, 所以给 “文件名:行号” 前后加了空格, 就能在IDE中直接点击定位到源码对应的行, 非常地方便, 感谢这位同事)</li></ul><p>在IDE中加个live template, 写errf回车就补全到<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.Errorf(err,<span class="string">"&#123;&#123;光标&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后补充必要的注释和参数就行了, 在本地环境调试时看到错误日志点击就可以定位到源码, 在非本地环境跑看到错误日志相比之前也能更好地知道发生了什么, 复制文件名:行号到IDE中就能定位到源码, 大大减轻了错误处理的繁琐.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Go的错误处理一直被吐槽太繁琐, 作为主要用GO的攻城狮, 经常写 &lt;code&gt;if err!=nil&lt;/code&gt;, 但是如果想偷懒, 少带了上下文信息, 直接写 &lt;code&gt;if err!=nil { return err}&lt;/code&gt; 或者
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="Error handling" scheme="https://imhanjm.com/tags/Error-handling/"/>
    
      <category term="错误处理" scheme="https://imhanjm.com/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>深入理解NATS &amp; NATS Streaming (踩坑记)</title>
    <link href="https://imhanjm.com/2018/02/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3NATS%20&amp;%20NATS%20Streaming/"/>
    <id>https://imhanjm.com/2018/02/17/深入理解NATS &amp; NATS Streaming/</id>
    <published>2018-02-16T16:00:00.000Z</published>
    <updated>2018-09-01T04:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NATS Server是一个高性能的, cloud native的, 基于发布订阅机制的消息系统, 没有消息持久化功能.<br>NATS Streaming Server是基于NATS Server的, 增加消息持久化功能的消息系统.</p><h2 id="NATS-Streaming-持久化特性踩坑记"><a href="#NATS-Streaming-持久化特性踩坑记" class="headerlink" title="NATS Streaming 持久化特性踩坑记"></a>NATS Streaming 持久化特性踩坑记</h2><p>官网的文档并不详细, 很多重要的技术细节没说, 看了官网的文档之后发现用法很简单, 然后直接去写代码, 写publisher代码没什么问题, 写subscriber代码也能正常工作. 但是subscriber一重启, 重启后重启期间publisher发的消息不会继续收到, 说好的持久化呢? 我把官网的文档翻了遍也没找到答案. 最后在项目的readme.md中找到了答案: 要让subscriber重启后能继续收到重启期间发过来的消息且不重复消息, 必须在调用<code>Subscribe(subject string, cb MsgHandler, opts ...SubscriptionOption) (Subscription, error)</code>订阅时设置一样的durableName, 且重启后连接时<code>Connect(stanClusterID, clientID string, options ...Option) (Conn, error)</code>ClusterID、clientID不能变.</p><p>要想理解NATS和NATS Streaming的特性, server和client的readme文档都需要仔细阅读, 特别是nats-streaming服务端的readme. 代码也值得阅读研究.</p><ul><li>gnatsd服务端 <a href="https://github.com/nats-io/gnatsd" target="_blank" rel="noopener">https://github.com/nats-io/gnatsd</a></li><li>gnatsd客户端 <a href="https://github.com/nats-io/go-nats" target="_blank" rel="noopener">https://github.com/nats-io/go-nats</a></li><li>nats-streaming服务端 <a href="https://github.com/nats-io/nats-streaming-server" target="_blank" rel="noopener">https://github.com/nats-io/nats-streaming-server</a></li><li>nats-streaming客户端 <a href="https://github.com/nats-io/go-nats-streaming" target="_blank" rel="noopener">https://github.com/nats-io/go-nats-streaming</a></li></ul><h2 id="重要特性说明"><a href="#重要特性说明" class="headerlink" title="重要特性说明"></a>重要特性说明</h2><ol><li>当subject没有被订阅时, 消息会被直接丢弃, 所以重启订阅者会丢消息, 解决办法: 要么开2个以上客户端实例, 组成队列订阅QueueSubscribe, 要么换NATS Streaming.</li><li>clientID和durableName对于NATS Streaming非常重要. 要让subscriber重启后能继续收到重启期间发过来的消息且不重复消息, 必须在调用<code>Subscribe(subject string, cb MsgHandler, opts ...SubscriptionOption) (Subscription, error)</code>订阅时设置一样的durableName, 调用<code>Connect(stanClusterID, clientID string, options ...Option) (Conn, error)</code>连接时ClusterID、clientID不能变. 程序关闭时应该使用Close而不是Unsubscribe, Unsubscribe()会删除在server端删除该持久化订阅.<blockquote><p>This client ID links a given connection to its published messages, subscriptions, especially durable subscriptions. Indeed, durable subscriptions are stored as a combination of the client ID and durable name.<br>If an application wishes to resume message consumption from where it previously stopped, it needs to create a durable subscription. It does so by providing a durable name, which is combined with the client ID provided when the client created its connection. The server then maintain the state for this subscription even after the client connection is closed.<br> Note: The starting position given by the client when restarting a durable subscription is ignored.<br> When the application wants to stop receiving messages on a durable subscription, it should close - but <em>not unsubscribe</em>- this subscription. If a given client library does not have the option to close a subscription, the application should close the connection instead.<br> When the application wants to delete the subscription, it must unsubscribe it. Once unsubscribed, the state is removed and it is then possible to re-use the durable name, but it will be considered a brand new durable subscription, with the start position being the one given by the client when creating the durable subscription.</p></blockquote></li></ol><h4 id><a href="#" class="headerlink" title></a><a href="https://github.com/nats-io/nats-streaming-server#queue-group" target="_blank" rel="noopener"></a></h4><ol start="3"><li><p>NATS连接时可以设置客户端的名字, 这样在monitor界面中的/connz就能方便地看到各个客户端的统计数据.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Options that can be passed to Connect.   // Name is an Option to set the client name. func Name(name string) Option &#123;</span><br><span class="line">   return func(o *Options) error &#123;</span><br><span class="line">      o.Name = name</span><br><span class="line">      return nil</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ConnInfo struct &#123;</span><br><span class="line">Cid            uint64    `json:&quot;cid&quot;`</span><br><span class="line">IP             string    `json:&quot;ip&quot;`</span><br><span class="line">Port           int       `json:&quot;port&quot;`</span><br><span class="line">Start          time.Time `json:&quot;start&quot;`</span><br><span class="line">LastActivity   time.Time `json:&quot;last_activity&quot;`</span><br><span class="line">Uptime         string    `json:&quot;uptime&quot;`</span><br><span class="line">Idle           string    `json:&quot;idle&quot;`</span><br><span class="line">Pending        int       `json:&quot;pending_bytes&quot;`</span><br><span class="line">InMsgs         int64     `json:&quot;in_msgs&quot;`</span><br><span class="line">OutMsgs        int64     `json:&quot;out_msgs&quot;`</span><br><span class="line">InBytes        int64     `json:&quot;in_bytes&quot;`</span><br><span class="line">OutBytes       int64     `json:&quot;out_bytes&quot;`</span><br><span class="line">NumSubs        uint32    `json:&quot;subscriptions&quot;`</span><br><span class="line">Name           string    `json:&quot;name,omitempty&quot;`</span><br><span class="line">Lang           string    `json:&quot;lang,omitempty&quot;`</span><br><span class="line">Version        string    `json:&quot;version,omitempty&quot;`</span><br><span class="line">TLSVersion     string    `json:&quot;tls_version,omitempty&quot;`</span><br><span class="line">TLSCipher      string    `json:&quot;tls_cipher_suite,omitempty&quot;`</span><br><span class="line">AuthorizedUser string    `json:&quot;authorized_user,omitempty&quot;`</span><br><span class="line">Subs           []string  `json:&quot;subscriptions_list,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用.来分隔subject的级别. NATS允许subject包含斜杠/符号, 但NATS Streaming不允许, 因为NATS Streaming持久化时会使用subject名字来作为文件夹名, </p><ul><li>NATS的subject可以为任意不为空的字符串, 具体的subject不能包含通配符’*’和’&gt;’.</li><li>NATS Streaming的subject不能为空, 首尾不能为点’.’, 不能包含两个连续的点’.’, 由于暂时不支持通配符订阅功能, 所以不能包含’*’和’&gt;’.</li></ul></li><li>NATS Streaming Server实际上是内嵌了一个NATS Server, 自己作为NATS的客户端. NATS Streaming的客户端实际上没有和NATS Streaming Server直接连接, 而是连接内嵌的NATS Server, NATS Streaming Server通过订阅客户端的心跳来知道NATS Streaming客户端连接有没有断开. 所以它强烈建议客户端退出程序时主动Close.</li><li>NATS可以热重新加载配置, 发送SIGHUP信号或<code>gnatsd -sl reload</code>即可.</li><li>开发环境可以加<code>-V</code>参数了解NATS, 生产环境就没必要了, 否则会把发过来的消息全打在日志里.</li><li>你甚至可以用NATS的client包publish消息到NATS Streaming, NATS的client可以subscribe, 但NATS Streaming的client无法subscribe, 因为内部的subject变了. 最好不用混用, 容易出问题.</li><li><p>NATS Streaming客户端连接时提供的ClusterID和服务端启动配置的ClusterID不一致时会报, 有人表示费解吐槽过, <a href="https://github.com/nats-io/nats-streaming-server/issues/309" target="_blank" rel="noopener">https://github.com/nats-io/nats-streaming-server/issues/309</a>, 但官方解释说没有问题, Timeout也说的通.</p><blockquote><p>If you provide a cluster ID not used by any of the servers in the network, no server will respond to the client, hence the timeout error message from the client library. If anything, this is an error message that needs to be updated in the client libraries, not in the server.</p></blockquote></li><li><p>ChanSubscribe方式的客户端优雅关闭, 等待消息处理完成.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line"> &quot;os&quot; &quot;syscall&quot; &quot;os/signal&quot; &quot;github.com/nats-io/go-nats&quot; &quot;sync&quot; )</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   n, err := nats.Connect(&quot;nats://127.0.0.1:7222&quot;,</span><br><span class="line">  nats.Name(&quot;test_client&quot;),</span><br><span class="line">  nats.UserInfo(&quot;&quot;, &quot;&quot;))</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      panic(err)</span><br><span class="line">   &#125;</span><br><span class="line">   subject := &quot;test&quot;</span><br><span class="line">  msgCh := make(chan *nats.Msg, nats.DefaultMaxChanLen)</span><br><span class="line">   _, err = n.ChanSubscribe(subject, msgCh)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      panic(err)</span><br><span class="line">   &#125;</span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">   for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">      wg.Add(1)</span><br><span class="line">      go func() &#123;</span><br><span class="line">         defer wg.Done()</span><br><span class="line">         // msg handler</span><br><span class="line">  for msg := range msgCh &#123;</span><br><span class="line">            fmt.Printf(&quot;%s\n&quot;, msg.Data)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   quit := make(chan os.Signal)</span><br><span class="line">   signal.Notify(quit, syscall.SIGQUIT,</span><br><span class="line">  syscall.SIGTERM,</span><br><span class="line">  syscall.SIGINT,</span><br><span class="line">  syscall.SIGUSR1,</span><br><span class="line">  syscall.SIGUSR2)</span><br><span class="line">   select &#123;</span><br><span class="line">   case &lt;-quit:</span><br><span class="line">      defer wg.Wait()</span><br><span class="line">      // close msgCh and wait process ok</span><br><span class="line">      close(msgCh)</span><br><span class="line">      n.Flush()</span><br><span class="line">      n.Close()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="NATS代码中的技巧"><a href="#NATS代码中的技巧" class="headerlink" title="NATS代码中的技巧"></a>NATS代码中的技巧</h2><ol><li><p>很有用的Go风格的可选参数设计模式, 很多地方见过.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Option is a function on the options for a connection. </span><br><span class="line">type Option func(*Options) error</span><br><span class="line"></span><br><span class="line">// Options can be used to create a customized connection. </span><br><span class="line">type Options struct &#123; </span><br><span class="line">  Url string   </span><br><span class="line"> ... </span><br><span class="line">  User string</span><br><span class="line">  Password string</span><br><span class="line">&#125;</span><br><span class="line">var DefaultOptions = Options&#123;</span><br><span class="line">   AllowReconnect:   true,</span><br><span class="line">  MaxReconnect:     DefaultMaxReconnect,</span><br><span class="line">  ReconnectWait:    DefaultReconnectWait,</span><br><span class="line">  Timeout:          DefaultTimeout,</span><br><span class="line">  PingInterval:     DefaultPingInterval,</span><br><span class="line">  MaxPingsOut:      DefaultMaxPingOut,</span><br><span class="line">  SubChanLen:       DefaultMaxChanLen,</span><br><span class="line">  ReconnectBufSize: DefaultReconnectBufSize,</span><br><span class="line">  Dialer: &amp;net.Dialer&#123;</span><br><span class="line">      Timeout: DefaultTimeout,</span><br><span class="line">  &#125;, &#125;</span><br><span class="line"></span><br><span class="line">// Connect will attempt to connect to the NATS system. </span><br><span class="line">// The url can contain username/password semantics. e.g. nats://derek:pass@localhost:4222 </span><br><span class="line">// Comma separated arrays are also supported, e.g. urlA, urlB. </span><br><span class="line">// Options start with the defaults but can be overridden. </span><br><span class="line">func Connect(url string, options ...Option) (*Conn, error) &#123;</span><br><span class="line">   opts := DefaultOptions</span><br><span class="line">   opts.Servers = processUrlString(url)</span><br><span class="line">   for _, opt := range options &#123;</span><br><span class="line">      if err := opt(&amp;opts); err != nil &#123;</span><br><span class="line">         return nil, err</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return opts.Connect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Options that can be passed to Connect.   // Name is an Option to set the client name. func Name(name string) Option &#123;</span><br><span class="line">   return func(o *Options) error &#123;</span><br><span class="line">      o.Name = name</span><br><span class="line">      return nil</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ringBuffer限制消息数量</p><blockquote><pre><code>You can view a message log as a ring buffer. Messages are appended to the end of the log. If a limit is set globally for all channels, or specifically for this channel, when the limit is reached, older messages are removed to make room for the new ones.</code></pre></blockquote></li><li><p>用reflect来绑定任意类型的chan</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chVal := reflect.ValueOf(channel)</span><br><span class="line">if chVal.Kind() != reflect.Chan &#123;</span><br><span class="line">   return ErrChanArg</span><br><span class="line">&#125;</span><br><span class="line">val, ok := chVal.Recv()</span><br><span class="line">if !ok &#123;</span><br><span class="line">   // Channel has most likely been closed.</span><br><span class="line">  return </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;NATS Server是一个高性能的, cloud native的, 基于发布订阅机制的消息系统, 没有消息持久化功能.&lt;br&gt;NATS
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="NATS" scheme="https://imhanjm.com/tags/NATS/"/>
    
      <category term="NATS Streaming" scheme="https://imhanjm.com/tags/NATS-Streaming/"/>
    
      <category term="消息队列" scheme="https://imhanjm.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>深入理解GO时间处理(time.Time)</title>
    <link href="https://imhanjm.com/2017/10/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86(time.Time)/"/>
    <id>https://imhanjm.com/2017/10/29/深入理解golang时间处理(time.Time)/</id>
    <published>2017-10-28T16:00:00.000Z</published>
    <updated>2017-11-04T07:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>时间包括时间值和时区, 没有包含时区信息的时间是不完整的、有歧义的. 和外界传递或解析时间数据时, 应当像HTTP协议或unix-timestamp那样, 使用没有时区歧义的格式, 如果使用某些没有包含时区的非标准的时间表示格式(如yyyy-mm-dd HH:MM:SS), 是有隐患的, 因为解析时会使用场景的默认设置, 如系统时区, 数据库默认时区可能引发事故. 确保服务器系统、数据库、应用程序使用统一的时区, 如果因为一些历史原因, 应用程序各自保持着不同时区, 那么编程时要小心检查代码, 知道时间数据在使用不同时区的程序之间交换时的行为. 第三节会详细解释go程序在不同场景下time.Time的行为.</p><h2 id="2-Time的数据结构"><a href="#2-Time的数据结构" class="headerlink" title="2. Time的数据结构"></a>2. Time的数据结构</h2><p>go1.9之前, time.Time的定义为</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// sec gives the number of seconds elapsed since</span></span><br><span class="line"><span class="comment">// January 1, year 1 00:00:00 UTC.</span></span><br><span class="line">sec <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nsec specifies a non-negative nanosecond</span></span><br><span class="line"><span class="comment">// offset within the second named by Seconds.</span></span><br><span class="line"><span class="comment">// It must be in the range [0, 999999999].</span></span><br><span class="line">nsec <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// loc specifies the Location that should be used to</span></span><br><span class="line"><span class="comment">// determine the minute, hour, month, day, and year</span></span><br><span class="line"><span class="comment">// that correspond to this Time.</span></span><br><span class="line"><span class="comment">// The nil location means UTC.</span></span><br><span class="line"><span class="comment">// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</span></span><br><span class="line">loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sec表示从公元1年1月1日00:00:00UTC到要表示的整数秒数, nsec表示余下的纳秒数, loc表示时区. sec和nsec处理没有歧义的时间值, loc处理偏移量.</p><p>因为2017年闰一秒, 国际时钟调整, Go程序两次取time.Now()相减的时间差得到了意料之外的负数, 导致cloudFlare的CDN服务中断, 详见<a href="https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/" target="_blank" rel="noopener">https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/</a>, go1.9在不影响已有应用代码的情况下修改了time.Time的实现. go1.9的time.Time定义为</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Time represents an instant in time with nanosecond precision.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Programs using times should typically store and pass them as values,</span></span><br><span class="line"><span class="comment">// not pointers. That is, time variables and struct fields should be of</span></span><br><span class="line"><span class="comment">// type time.Time, not *time.Time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Time value can be used by multiple goroutines simultaneously except</span></span><br><span class="line"><span class="comment">// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and</span></span><br><span class="line"><span class="comment">// UnmarshalText are not concurrency-safe.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Time instants can be compared using the Before, After, and Equal methods.</span></span><br><span class="line"><span class="comment">// The Sub method subtracts two instants, producing a Duration.</span></span><br><span class="line"><span class="comment">// The Add method adds a Time and a Duration, producing a Time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.</span></span><br><span class="line"><span class="comment">// As this time is unlikely to come up in practice, the IsZero method gives</span></span><br><span class="line"><span class="comment">// a simple way of detecting a time that has not been initialized explicitly.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Each Time has associated with it a Location, consulted when computing the</span></span><br><span class="line"><span class="comment">// presentation form of the time, such as in the Format, Hour, and Year methods.</span></span><br><span class="line"><span class="comment">// The methods Local, UTC, and In return a Time with a specific location.</span></span><br><span class="line"><span class="comment">// Changing the location in this way changes only the presentation; it does not</span></span><br><span class="line"><span class="comment">// change the instant in time being denoted and therefore does not affect the</span></span><br><span class="line"><span class="comment">// computations described in earlier paragraphs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that the Go == operator compares not just the time instant but also the</span></span><br><span class="line"><span class="comment">// Location and the monotonic clock reading. Therefore, Time values should not</span></span><br><span class="line"><span class="comment">// be used as map or database keys without first guaranteeing that the</span></span><br><span class="line"><span class="comment">// identical Location has been set for all values, which can be achieved</span></span><br><span class="line"><span class="comment">// through use of the UTC or Local method, and that the monotonic clock reading</span></span><br><span class="line"><span class="comment">// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)</span></span><br><span class="line"><span class="comment">// to t == u, since t.Equal uses the most accurate comparison available and</span></span><br><span class="line"><span class="comment">// correctly handles the case when only one of its arguments has a monotonic</span></span><br><span class="line"><span class="comment">// clock reading.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In addition to the required “wall clock” reading, a Time may contain an optional</span></span><br><span class="line"><span class="comment">// reading of the current process's monotonic clock, to provide additional precision</span></span><br><span class="line"><span class="comment">// for comparison or subtraction.</span></span><br><span class="line"><span class="comment">// See the “Monotonic Clocks” section in the package documentation for details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// wall and ext encode the wall time seconds, wall time nanoseconds,</span></span><br><span class="line"><span class="comment">// and optional monotonic clock reading in nanoseconds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),</span></span><br><span class="line"><span class="comment">// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.</span></span><br><span class="line"><span class="comment">// The nanoseconds field is in the range [0, 999999999].</span></span><br><span class="line"><span class="comment">// If the hasMonotonic bit is 0, then the 33-bit field must be zero</span></span><br><span class="line"><span class="comment">// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.</span></span><br><span class="line"><span class="comment">// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit</span></span><br><span class="line"><span class="comment">// unsigned wall seconds since Jan 1 year 1885, and ext holds a</span></span><br><span class="line"><span class="comment">// signed 64-bit monotonic clock reading, nanoseconds since process start.</span></span><br><span class="line">wall <span class="keyword">uint64</span></span><br><span class="line">ext  <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// loc specifies the Location that should be used to</span></span><br><span class="line"><span class="comment">// determine the minute, hour, month, day, and year</span></span><br><span class="line"><span class="comment">// that correspond to this Time.</span></span><br><span class="line"><span class="comment">// The nil location means UTC.</span></span><br><span class="line"><span class="comment">// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</span></span><br><span class="line">loc *Location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-time的行为"><a href="#3-time的行为" class="headerlink" title="3. time的行为"></a>3. time的行为</h2><ol><li><p>构造时间-获取现在时间-time.Now(), time.Now()使用本地时间, time.Local即本地时区, 取决于运行的系统环境设置, 优先取”TZ”这个环境变量, 然后取/etc/localtime, 都取不到就用UTC兜底.</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">sec, nsec := now()</span><br><span class="line"><span class="keyword">return</span> Time&#123;sec + unixToInternal, nsec, Local&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>构造时间-获取某一时区的现在时间-time.Now().In(), Time结构体的<code>In()</code>方法仅设置loc, 不会改变时间值. 特别地, 如果是获取现在的UTC时间, 可以使用Time.Now().UTC().<br>时区不能为nil. time包中只有两个时区变量time.Local和time.UTC. 其他时区变量有两种方法取得, 一个是通过time.LoadLocation函数根据时区名字加载, 时区名字见<a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA Time Zone database</a>, LoadLocation首先查找系统zoneinfo, 然后查找<code>$GOROOT/lib/time/zoneinfo.zip</code>.另一个是在知道时区名字和偏移量的情况下直接调用<code>time.FixedZone(&quot;$zonename&quot;, $offsetSecond)</code>构造一个Location对象.</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In returns t with the location information set to loc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In panics if loc is nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">In</span><span class="params">(loc *Location)</span> <span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"time: missing Location in call to Time.In"</span>)</span><br><span class="line">&#125;</span><br><span class="line">t.setLoc(loc)</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoadLocation returns the Location with the given name.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the name is "" or "UTC", LoadLocation returns UTC.</span></span><br><span class="line"><span class="comment">// If the name is "Local", LoadLocation returns Local.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the name is taken to be a location name corresponding to a file</span></span><br><span class="line"><span class="comment">// in the IANA Time Zone database, such as "America/New_York".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The time zone database needed by LoadLocation may not be</span></span><br><span class="line"><span class="comment">// present on all systems, especially non-Unix systems.</span></span><br><span class="line"><span class="comment">// LoadLocation looks in the directory or uncompressed zip file</span></span><br><span class="line"><span class="comment">// named by the ZONEINFO environment variable, if any, then looks in</span></span><br><span class="line"><span class="comment">// known installation locations on Unix systems,</span></span><br><span class="line"><span class="comment">// and finally looks in $GOROOT/lib/time/zoneinfo.zip.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadLocation</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Location, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">""</span> || name == <span class="string">"UTC"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> UTC, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"Local"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Local, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> zoneinfo != <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">if</span> z, err := loadZoneFile(zoneinfo, name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">z.name = name</span><br><span class="line"><span class="keyword">return</span> z, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadLocation(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>构造时间-手动构造时间-time.Date(), 传入年元日时分秒纳秒和时区变量Location构造一个时间. 得到的是指定location的时间.</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="keyword">int</span>, month Month, day, hour, min, sec, nsec <span class="keyword">int</span>, loc *Location)</span> <span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> loc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"time: missing Location in call to Date"</span>)</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>构造时间-从unix时间戳中构造时间, time.Unix(), 传入秒和纳秒构造.</li><li><p>序列化反序列化时间-文本和JSON, fmt.Sprintf,fmt.SScanf, json.Marshal, json.Unmarshal时的, 使用的时间格式均包含时区信息, 序列化使用RFC3339Nano()”2006-01-02T15:04:05.999999999Z07:00”, 反序列化使用RFC3339()”2006-01-02T15:04:05Z07:00”, 反序列化没有纳秒值也可以正常序列化成功.</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String returns the time formatted using the format string</span></span><br><span class="line"><span class="comment">//"2006-01-02 15:04:05.999999999 -0700 MST"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05.999999999 -0700 MST"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MarshalJSON implements the json.Marshaler interface.</span></span><br><span class="line"><span class="comment">// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> y := t.Year(); y &lt; <span class="number">0</span> || y &gt;= <span class="number">10000</span> &#123;</span><br><span class="line"><span class="comment">// RFC 3339 is clear that years are 4 digits exactly.</span></span><br><span class="line"><span class="comment">// See golang.org/issue/4556#c15 for more discussion.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Time.MarshalJSON: year outside of range [0,9999]"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(RFC3339Nano)+<span class="number">2</span>)</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line">b = t.AppendFormat(b, RFC3339Nano)</span><br><span class="line">b = <span class="built_in">append</span>(b, <span class="string">'"'</span>)</span><br><span class="line"><span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmarshalJSON implements the json.Unmarshaler interface.</span></span><br><span class="line"><span class="comment">// The time is expected to be a quoted string in RFC 3339 format.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Ignore null, like in the main JSON package.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">string</span>(data) == <span class="string">"null"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Fractional seconds are handled implicitly by Parse.</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">*t, err = Parse(<span class="string">`"`</span>+RFC3339+<span class="string">`"`</span>, <span class="keyword">string</span>(data))</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>序列化反序列化时间-HTTP协议中的date, 统一GMT, 代码位于net/http/server.go:878</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TimeFormat is the time format to use when generating times in HTTP</span></span><br><span class="line"><span class="comment">// headers. It is like time.RFC1123 but hard-codes GMT as the time</span></span><br><span class="line"><span class="comment">// zone. The time being formatted must be in UTC for Format to</span></span><br><span class="line"><span class="comment">// generate the correct format.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For parsing this time format, see ParseTime.</span></span><br><span class="line"><span class="keyword">const</span> TimeFormat = <span class="string">"Mon, 02 Jan 2006 15:04:05 GMT"</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>序列化反序列化时间-<code>time.Format(&quot;$layout&quot;)</code>, <code>time.Parse(&quot;$layout&quot;,&quot;$value&quot;)</code>, <code>time.ParseInLocation(&quot;$layout&quot;,&quot;$value&quot;,&quot;$Location&quot;)</code></p><ul><li><code>time.Format(&quot;$layout&quot;)</code>格式化时间时, 时区会参与计算. 调time.Time的Year()Month()Day()等获取年月日等时时区会参与计算, 得到一个使用偏移量修正过的正确的时间字符串, 若<code>$layout</code>有指定显示时区, 那么时区信息会体现在格式化后的时间字符串中. 如果<code>$layout</code>没有指定显示时区, 那么字符串只有时间没有时区, 时区是隐含的, time.Time对象中的时区.</li><li><code>time.Parse(&quot;$layout&quot;,&quot;$value&quot;)</code>, 若<code>$layout</code>有指定显示时区, 那么时区信息会体现在格式化后的time.Time对象. <strong>如果<code>$layout</code>没有指定显示时区, 那么使用会认为这是一个UTC时间, 时区是UTC.</strong></li><li><p><code>time.ParseInLocation(&quot;$layout&quot;,&quot;$value&quot;,&quot;$Location&quot;)</code> 使用传参的时区解析时间, 建议用这个, 没有歧义.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Parse parses a formatted string and returns the time value it represents.</span></span><br><span class="line"><span class="comment">// The layout  defines the format by showing how the reference time,</span></span><br><span class="line"><span class="comment">// defined to be</span></span><br><span class="line"><span class="comment">//Mon Jan 2 15:04:05 -0700 MST 2006</span></span><br><span class="line"><span class="comment">// would be interpreted if it were the value; it serves as an example of</span></span><br><span class="line"><span class="comment">// the input format. The same interpretation will then be made to the</span></span><br><span class="line"><span class="comment">// input string.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard</span></span><br><span class="line"><span class="comment">// and convenient representations of the reference time. For more information</span></span><br><span class="line"><span class="comment">// about the formats and the definition of the reference time, see the</span></span><br><span class="line"><span class="comment">// documentation for ANSIC and the other constants defined by this package.</span></span><br><span class="line"><span class="comment">// Also, the executable example for time.Format demonstrates the working</span></span><br><span class="line"><span class="comment">// of the layout string in detail and is a good reference.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Elements omitted from the value are assumed to be zero or, when</span></span><br><span class="line"><span class="comment">// zero is impossible, one, so parsing "3:04pm" returns the time</span></span><br><span class="line"><span class="comment">// corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is</span></span><br><span class="line"><span class="comment">// 0, this time is before the zero Time).</span></span><br><span class="line"><span class="comment">// Years must be in the range 0000..9999. The day of the week is checked</span></span><br><span class="line"><span class="comment">// for syntax but it is otherwise ignored.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the absence of a time zone indicator, Parse returns a time in UTC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When parsing a time with a zone offset like -0700, if the offset corresponds</span></span><br><span class="line"><span class="comment">// to a time zone used by the current location (Local), then Parse uses that</span></span><br><span class="line"><span class="comment">// location and zone in the returned time. Otherwise it records the time as</span></span><br><span class="line"><span class="comment">// being in a fabricated location with time fixed at the given zone offset.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// No checking is done that the day of the month is within the month's</span></span><br><span class="line"><span class="comment">// valid dates; any one- or two-digit value is accepted. For example</span></span><br><span class="line"><span class="comment">// February 31 and even February 99 are valid dates, specifying dates</span></span><br><span class="line"><span class="comment">// in March and May. This behavior is consistent with time.Date.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When parsing a time with a zone abbreviation like MST, if the zone abbreviation</span></span><br><span class="line"><span class="comment">// has a defined offset in the current location, then that offset is used.</span></span><br><span class="line"><span class="comment">// The zone abbreviation "UTC" is recognized as UTC regardless of location.</span></span><br><span class="line"><span class="comment">// If the zone abbreviation is unknown, Parse records the time as being</span></span><br><span class="line"><span class="comment">// in a fabricated location with the given zone abbreviation and a zero offset.</span></span><br><span class="line"><span class="comment">// This choice means that such a time can be parsed and reformatted with the</span></span><br><span class="line"><span class="comment">// same layout losslessly, but the exact instant used in the representation will</span></span><br><span class="line"><span class="comment">// differ by the actual zone offset. To avoid such problems, prefer time layouts</span></span><br><span class="line"><span class="comment">// that use a numeric zone offset, or use ParseInLocation.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="keyword">string</span>)</span> <span class="params">(Time, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> parse(layout, value, UTC, Local)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseInLocation is like Parse but differs in two important ways.</span></span><br><span class="line"><span class="comment">// First, in the absence of time zone information, Parse interprets a time as UTC;</span></span><br><span class="line"><span class="comment">// ParseInLocation interprets the time as in the given location.</span></span><br><span class="line"><span class="comment">// Second, when given a zone offset or abbreviation, Parse tries to match it</span></span><br><span class="line"><span class="comment">// against the Local location; ParseInLocation uses the given location.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="keyword">string</span>, loc *Location)</span> <span class="params">(Time, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> parse(layout, value, loc, loc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(layout, value <span class="keyword">string</span>, defaultLocation, local *Location)</span> <span class="params">(Time, error)</span></span> &#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>序列化反序列化时间-go-sql-driver/mysql中的时间处理.<br>MySQL驱动解析时间的前提是连接字符串加了parseTime和loc, 如果parseTime为false, 会把mysql的date类型变成[]byte/string自行处理, parseTime为true才处理时间, loc指定MySQL中存储时间数据的时区, 如果没有指定loc, 用UTC. 序列化和反序列化均使用连接字符串中的设定的loc, SQL语句中的time.Time类型的参数的时区信息如果和loc不同, 则会调用<code>t.In(loc)</code>方法转时区.</p><ul><li><p>解析连接字符串的代码位于parseDSNParams函数<a href="https://github.com/go-sql-driver/mysql/blob/master/dsn.go#L467-L490" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql/blob/master/dsn.go#L467-L490</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Time Location</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"loc"</span>:</span><br><span class="line"><span class="keyword">if</span> value, err = url.QueryUnescape(value); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cfg.Loc, err = time.LoadLocation(value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// time.Time parsing</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"parseTime"</span>:</span><br><span class="line"><span class="keyword">var</span> isBool <span class="keyword">bool</span></span><br><span class="line">cfg.ParseTime, isBool = readBool(value)</span><br><span class="line"><span class="keyword">if</span> !isBool &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"invalid bool value: "</span> + value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析SQL语句中time.Time类型的参数的代码位于mysqlConn.interpolateParams方法<a href="https://github.com/go-sql-driver/mysql/blob/master/connection.go#L230-L273" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql/blob/master/connection.go#L230-L273</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> time.Time:</span><br><span class="line"><span class="keyword">if</span> v.IsZero() &#123;</span><br><span class="line">buf = <span class="built_in">append</span>(buf, <span class="string">"'0000-00-00'"</span>...)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v := v.In(mc.cfg.Loc)</span><br><span class="line">v = v.Add(time.Nanosecond * <span class="number">500</span>) <span class="comment">// To round under microsecond</span></span><br><span class="line">year := v.Year()</span><br><span class="line">year100 := year / <span class="number">100</span></span><br><span class="line">year1 := year % <span class="number">100</span></span><br><span class="line">month := v.Month()</span><br><span class="line">day := v.Day()</span><br><span class="line">hour := v.Hour()</span><br><span class="line">minute := v.Minute()</span><br><span class="line">second := v.Second()</span><br><span class="line">micro := v.Nanosecond() / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">buf = <span class="built_in">append</span>(buf, []<span class="keyword">byte</span>&#123;</span><br><span class="line"><span class="string">'\''</span>,</span><br><span class="line">digits10[year100], digits01[year100],</span><br><span class="line">digits10[year1], digits01[year1],</span><br><span class="line"><span class="string">'-'</span>,</span><br><span class="line">digits10[month], digits01[month],</span><br><span class="line"><span class="string">'-'</span>,</span><br><span class="line">digits10[day], digits01[day],</span><br><span class="line"><span class="string">' '</span>,</span><br><span class="line">digits10[hour], digits01[hour],</span><br><span class="line"><span class="string">':'</span>,</span><br><span class="line">digits10[minute], digits01[minute],</span><br><span class="line"><span class="string">':'</span>,</span><br><span class="line">digits10[second], digits01[second],</span><br><span class="line">&#125;...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> micro != <span class="number">0</span> &#123;</span><br><span class="line">micro10000 := micro / <span class="number">10000</span></span><br><span class="line">micro100 := micro / <span class="number">100</span> % <span class="number">100</span></span><br><span class="line">micro1 := micro % <span class="number">100</span></span><br><span class="line">buf = <span class="built_in">append</span>(buf, []<span class="keyword">byte</span>&#123;</span><br><span class="line"><span class="string">'.'</span>,</span><br><span class="line">digits10[micro10000], digits01[micro10000],</span><br><span class="line">digits10[micro100], digits01[micro100],</span><br><span class="line">digits10[micro1], digits01[micro1],</span><br><span class="line">&#125;...)</span><br><span class="line">&#125;</span><br><span class="line">buf = <span class="built_in">append</span>(buf, <span class="string">'\''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从MySQL数据流中解析时间的代码位于textRows.readRow方法<a href="https://github.com/go-sql-driver/mysql/blob/master/packets.go#L772-L777" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql/blob/master/packets.go#L772-L777</a>, <strong>注意只要MySQL连接字符串设置了parseTime=true, 就会解析时间, 不管你是用string还是time.Time接收的.</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !isNull &#123;</span><br><span class="line"><span class="keyword">if</span> !mc.parseTime &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> rows.rs.columns[i].fieldType &#123;</span><br><span class="line"><span class="keyword">case</span> fieldTypeTimestamp, fieldTypeDateTime,</span><br><span class="line">fieldTypeDate, fieldTypeNewDate:</span><br><span class="line">dest[i], err = parseDateTime(</span><br><span class="line"><span class="keyword">string</span>(dest[i].([]<span class="keyword">byte</span>)),</span><br><span class="line">mc.cfg.Loc,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="4-time时区处理不当案例"><a href="#4-time时区处理不当案例" class="headerlink" title="4. time时区处理不当案例"></a>4. time时区处理不当案例</h2><ol><li><p>有个服务频繁使用最新汇率, 所以缓存了最新汇率对象, 汇率对象的过期时间设为第二天北京时间零点, 汇率过期则从数据库中去最新汇率, 设置过期时间的代码如下:</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime <span class="keyword">string</span> = time.Now().UTC().Add(<span class="number">8</span> * time.Hour).Format(<span class="string">"2006-01-02"</span>)</span><br><span class="line">tm2, _ := time.Parse(<span class="string">"2006-01-02"</span>, startTime)</span><br><span class="line">lastTime = tm2.Unix() + <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span></span><br></pre></td></tr></table></figure><p> 这段代码使用了time.Parse, 如果时间格式中没有指定时区, 那么会得到使用本地时区下的第二天零点, 服务器时区设置为UTC0, 于是汇率缓存在UTC零点即北京时间八点才更新.</p></li><li><p>公共库中有一个GetBjTime()方法, 注释写着将服务器UTC转成北京时间, 代码如下</p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBjTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="comment">// 将服务器UTC转成北京时间</span></span><br><span class="line">uTime := time.Now().UTC()</span><br><span class="line">dur, _ := time.ParseDuration(<span class="string">"+8h"</span>)</span><br><span class="line"><span class="keyword">return</span> uTime.Add(dur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBjTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="comment">// 将服务器UTC转成北京时间</span></span><br><span class="line">uTime := time.Now()</span><br><span class="line"><span class="keyword">return</span> uTime.In(time.FixedZone(<span class="string">"CST"</span>, <span class="number">8</span>*<span class="number">60</span>*<span class="number">60</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 同事用这个方法将得到的time.Time参与计算, 发现多了8个小时. 觉得有问题, 同事和我讨论了之后, 我们得出结论后就大意地直接把原有函数改了, 我们都没有意识到这是个非常危险操作, 只所以危险是因为这个函数已经在很多服务的代码里用着(要稳!不能乱动公共库!!!). 之前用这个函数是因为老Java项目运行在时区为东八区的系统上, 大量代码使用东八区时间, 但数据库MySQL时区设置为UTC, go项目也运行在UTC时区. 也就是说, Java项目在把时区为UTC数据库当做是东八区来用, Java程序往MySQL写东八区的时间字符串, 在sequel软件中看表内容时虽然字符串是一样的, 但其实内部是UTC的时间, go代码的mysql连接字符串中loc选项为空, 就会使用UTC时区去解析数据, 拿到的数据会多八个小时. 例如Java代码往mysql插入一条”2017-10-29 22:00:00”数据本意是东八区2017年10月29日22点, 但在MySQL内部看来, 这是UTC的2017年10月29日22点, 换算成东八区时间为2017年10月30日6点, 如果其它程序解析时认为时间数据是MySQL的UTC时区, 那么会得到一个错误的时间. 所以才会在GO中要往Java代码创建的表写入数据时用<code>time.Now().UTC().Add(time.Hour*8)</code>直接相加八小时使得Java项目行为一致, 拿UTC的数据库存东八区时间. </p><p> 后面想想, 面对这种数据库中有时区不一致数据的情况, 在没有办法统一UTC时区的情况下, 应当使用MySQL时间字符串而不是time.Time来传递以避免时区隐含转换问题, 写入时参数传string类型的时间字符串, 解析时先拿到时间字符串, 然后自行判断建表时这个字段用的是东八区的时间字符串还是UTC时间字符串进行time.ParseInLocation得到时间对象, MySQL连接字符串的parseTime选项要设置为false.  比如我想在MySQL中存东八区的当前时间, SQL参数用Format后的字符串而不是传time.Time, 原版的<code>time.Now().UTC().Add(time.Hour*8).Format(&quot;2006-01-02 15:04:05&quot;)</code>和修改的<code>time.Now().In(time.FixedZone(&quot;CST&quot;, 8*60*60))</code>的输出将是一样, 但后者是正确的东八区现在时间. 原版的GetBjTime()返回time.Time可能用GetBeijingNowTimeString返回string更能体现本意吧.</p></li></ol><h2 id="5-时间有关的标准"><a href="#5-时间有关的标准" class="headerlink" title="5. 时间有关的标准"></a>5. 时间有关的标准</h2><ul><li><p><a href="https://zh.wikipedia.org/wiki/UTC" target="_blank" rel="noopener">UTC</a> </p><blockquote><p>协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。中华民国采用CNS 7648的《资料元及交换格式–资讯交换–日期及时间的表示法》（与ISO 8601类似）称之为世界协调时间。中华人民共和国采用ISO 8601:2000的国家标准GB/T 7408-2005《数据元和交换格式 信息交换 日期和时间表示法》中亦称之为协调世界时。<br>协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒[4]，并不遵守夏令时。协调世界时是最接近格林威治标准时间(GMT)的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。</p></blockquote></li><li><p><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO 8601</a> 计算某一天在一年的第几周/循环时间RRlue/会用到此标准</p><blockquote><p>国际标准ISO 8601，是国际标准化组织的日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是第三版“ISO8601:2004”以替代第一版“ISO8601:1988”与第二版“ISO8601:2000”。</p></blockquote></li><li><a href="https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">UNIX时间</a><blockquote><p>UNIX时间，或称POSIX时间是UNIX或类UNIX系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒[1]。 在多数Unix系统上Unix时间可以通过date +%s指令来检查。</p></blockquote></li><li><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">时区</a><blockquote><p>时区列表</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;时间包括时间值和时区, 没有包含时区信息的时间是不完整的、有歧义的. 和外界传递或解析时间数据时,
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="时间处理" scheme="https://imhanjm.com/tags/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Go如何精确计算小数-Decimal研究-Tidb MyDecimal问题</title>
    <link href="https://imhanjm.com/2017/08/27/Go%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E8%AE%A1%E7%AE%97%E5%B0%8F%E6%95%B0-decimal%E7%A0%94%E7%A9%B6/"/>
    <id>https://imhanjm.com/2017/08/27/Go如何精确计算小数-decimal研究/</id>
    <published>2017-08-26T16:00:00.000Z</published>
    <updated>2017-11-05T06:16:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>##1 浮点数为什么不精确<br>先看两个case</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case1: 135.90*100 ====</span></span><br><span class="line"><span class="comment">// float32</span></span><br><span class="line"><span class="keyword">var</span> f1 <span class="keyword">float32</span> = <span class="number">135.90</span></span><br><span class="line">fmt.Println(f1 * <span class="number">100</span>) <span class="comment">// output:13589.999</span></span><br><span class="line"><span class="comment">// float64</span></span><br><span class="line"><span class="keyword">var</span> f2 <span class="keyword">float64</span> = <span class="number">135.90</span></span><br><span class="line">fmt.Println(f2 * <span class="number">100</span>) <span class="comment">// output:13590</span></span><br></pre></td></tr></table></figure><p>浮点数在单精度下, 135.9*100即出现了偏差, 双精度下结果正确.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case2: 0.1 add 10 times ===</span></span><br><span class="line"><span class="comment">// float32</span></span><br><span class="line"><span class="keyword">var</span> f3 <span class="keyword">float32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">f3 += <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f3) <span class="comment">//output:1.0000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float64</span></span><br><span class="line"><span class="keyword">var</span> f4 <span class="keyword">float64</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">f4 += <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f4) <span class="comment">//output:0.9999999999999999</span></span><br></pre></td></tr></table></figure><p>0.1加10次, 这下无论是float32和float64都出现了偏差.</p><p>为什么呢, Go和大多数语言一样, 使用标准的<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754</a>表示浮点数, 0.1使用二进制表示结果是一个无限循环数, 只能舍入后表示, 累加10次之后就会出现偏差.</p><p>此外, 还有几个隐藏的坑<a href="https://play.golang.org/p/bQPbirROmN" target="_blank" rel="noopener">https://play.golang.org/p/bQPbirROmN</a></p><ol><li>float32和float64直接互转会精度丢失, 四舍五入后错误.</li><li>int64转float64在数值很大的时候出现偏差.</li><li>合理但须注意: 两位小数乘100强转int, 比期望值少了1.</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// case: float32==&gt;float64</span></span><br><span class="line"><span class="comment">// 从数据库中取出80.45, 历史代码用float32接收</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">80.45</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// 有些函数只能接收float64, 只能强转</span></span><br><span class="line">b = <span class="keyword">float64</span>(a)</span><br><span class="line"><span class="comment">// 打印出值, 强转后出现偏差</span></span><br><span class="line">fmt.Println(a) <span class="comment">//output:80.45</span></span><br><span class="line">fmt.Println(b) <span class="comment">//output:80.44999694824219</span></span><br><span class="line"><span class="comment">// ... 四舍五入保留小数点后1位, 期望80.5, 结果是80.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case: int64==&gt;float64</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int64</span> = <span class="number">987654321098765432</span></span><br><span class="line">fmt.Printf(<span class="string">"%.f\n"</span>, <span class="keyword">float64</span>(c)) <span class="comment">//output:987654321098765440</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case: int(float64(xx.xx*100))</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">float64</span> = <span class="number">1129.6</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">int64</span> = <span class="keyword">int64</span>(d * <span class="number">100</span>)</span><br><span class="line">fmt.Println(e) <span class="comment">//output:112959</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##2 数据库是怎么做的<br>MySQL提供了decimal(p,d)/numberlic(p,d)类型的定点数表示法, 由p位数字(不包括符号、小数点)组成, 小数点后面有d位数字, 占p+2个字节, 计算性能会比double/float类型弱一些. </p><p>##3 Go代码如何实现Decimal<br>Java有成熟的标准库java.lang.BigDecimal,Python有标准库Decimal, 可惜GO没有. 在GitHub搜decimal, star数量比较多的是TiDB里的MyDecimal和ithub.com/shopspring/decimal的实现.</p><ul><li><p>shopspring的Decimal实现比较简单, 思路是使用十进制定点数表示法, 有多少位小数就小数点后移多少位, value保存移之后的整数, exp保存小数点后的数位个数, number=value*10^exp, 因为移小数点后的整数可能很大, 所以这里借用标准包里的math/big表示这个大整数. exp使用了int32, 所以这个包最多能表示小数点后有32个十进制数位的情况.</p><p>  Decimal结构体的定义如下</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decimal represents a fixed-point decimal. It is immutable.</span></span><br><span class="line"><span class="comment">// number = value * 10 ^ exp</span></span><br><span class="line"><span class="keyword">type</span> Decimal <span class="keyword">struct</span> &#123;</span><br><span class="line">value *big.Int</span><br><span class="line"></span><br><span class="line"><span class="comment">// NOTE(vadim): this must be an int32, because we cast it to float64 during</span></span><br><span class="line"><span class="comment">// calculations. If exp is 64 bit, we might lose precision.</span></span><br><span class="line"><span class="comment">// If we cared about being able to represent every possible decimal, we</span></span><br><span class="line"><span class="comment">// could make exp a *big.Int but it would hurt performance and numbers</span></span><br><span class="line"><span class="comment">// like that are unrealistic.</span></span><br><span class="line">exp <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TiDB里的MyDecimal定义位于<code>github.com/pingcap/tidb/util/types/mydecimal.go</code>, 实现比shopspring的Decimal复杂多了, 也更底层(不依赖math/big), 性能也更好(见下面的benchmark). 其思路是:<br>digitsInt保存数字的整数部分数字个数, digitsFrac保存数字的小数部分数字个数, resultFrac保存计算及序列化时保留至小数点后几位, negative标明数字是否为负数, wordBuf是一个定长的int32数组(长度为9), 数字去掉小数点的主体保存在这里, 一个int32有32个bit, 最大值为(<code>2**31-1</code>)2147483647(10个十进制数), 所以一个int32最多能表示9个十进制数位, 因此wordBuf 最多能容纳9*9个十进制数位.</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyDecimal represents a decimal value.</span></span><br><span class="line"><span class="keyword">type</span> MyDecimal <span class="keyword">struct</span> &#123;</span><br><span class="line">digitsInt <span class="keyword">int8</span> <span class="comment">// the number of *decimal* digits before the point.</span></span><br><span class="line"></span><br><span class="line">digitsFrac <span class="keyword">int8</span> <span class="comment">// the number of decimal digits after the point.</span></span><br><span class="line"></span><br><span class="line">resultFrac <span class="keyword">int8</span> <span class="comment">// result fraction digits.</span></span><br><span class="line"></span><br><span class="line">negative <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  wordBuf is an array of int32 words.</span></span><br><span class="line"><span class="comment">// A word is an int32 value can hold 9 digits.(0 &lt;= word &lt; wordBase)</span></span><br><span class="line">wordBuf [maxWordBufLen]<span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>看看这两种decimal类型在文首的两个case下的结果, 同时跑个分.</p><blockquote><p>main_test.go</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"github.com/shopspring/decimal"</span></span><br><span class="line"><span class="string">"github.com/pingcap/tidb/util/types"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> case1String = <span class="string">"135.90"</span></span><br><span class="line"><span class="keyword">var</span> case1Bytes = []<span class="keyword">byte</span>(case1String)</span><br><span class="line"><span class="keyword">var</span> case2String = <span class="string">"0"</span></span><br><span class="line"><span class="keyword">var</span> case2Bytes = []<span class="keyword">byte</span>(<span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShopspringDecimalCase1</span><span class="params">()</span> <span class="title">decimal</span>.<span class="title">Decimal</span></span> &#123;</span><br><span class="line">dec1, err := decimal.NewFromString(case1String)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">dec2 := decimal.NewFromFloat(<span class="number">100</span>)</span><br><span class="line">dec3 := dec1.Mul(dec2)</span><br><span class="line"><span class="keyword">return</span> dec3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TidbDecimalCase1</span><span class="params">()</span> *<span class="title">types</span>.<span class="title">MyDecimal</span></span> &#123;</span><br><span class="line">dec1 := <span class="built_in">new</span>(types.MyDecimal)</span><br><span class="line">err := dec1.FromString(case1Bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">dec2 := <span class="built_in">new</span>(types.MyDecimal).FromInt(<span class="number">100</span>)</span><br><span class="line">dec3 := <span class="built_in">new</span>(types.MyDecimal)</span><br><span class="line">err = types.DecimalMul(dec1, dec2, dec3)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dec3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShopspringDecimalCase2</span><span class="params">()</span> <span class="title">decimal</span>.<span class="title">Decimal</span></span> &#123;</span><br><span class="line">dec1, err := decimal.NewFromString(case2String)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">dec2 := decimal.NewFromFloat(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">dec1 = dec1.Add(dec2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dec1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TidbDecimalCase2</span><span class="params">()</span> *<span class="title">types</span>.<span class="title">MyDecimal</span></span> &#123;</span><br><span class="line">dec1 := <span class="built_in">new</span>(types.MyDecimal)</span><br><span class="line">dec1.FromString(case2Bytes)</span><br><span class="line">dec2 := <span class="built_in">new</span>(types.MyDecimal)</span><br><span class="line">dec2.FromFloat64(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">types.DecimalAdd(dec1, dec2, dec1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dec1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case1: 135.90*100 ====</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkShopspringDecimalCase1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">ShopspringDecimalCase1()</span><br><span class="line">&#125;</span><br><span class="line">b.Log(ShopspringDecimalCase1()) <span class="comment">// output: 13590</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTidbDecimalCase1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">TidbDecimalCase1()</span><br><span class="line">&#125;</span><br><span class="line">b.Log(TidbDecimalCase1()) <span class="comment">//  output: 13590.00</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case2: 0.1 add 10 times ===</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkShopspringDecimalCase2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">ShopspringDecimalCase2()</span><br><span class="line">&#125;</span><br><span class="line">b.Log(ShopspringDecimalCase2()) <span class="comment">//  output: 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTidbDecimalCase2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">TidbDecimalCase2()</span><br><span class="line">&#125;</span><br><span class="line">b.Log(TidbDecimalCase2()) <span class="comment">//  output: 1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BenchmarkShopspringDecimalCase1<span class="number">-8</span>        <span class="number">2000000</span>               <span class="number">664</span> ns/op             <span class="number">340</span> B/op         <span class="number">10</span> allocs/op</span><br><span class="line"></span><br><span class="line">BenchmarkTidbDecimalCase1<span class="number">-8</span>             <span class="number">20000000</span>                <span class="number">99.2</span> ns/op            <span class="number">48</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line"></span><br><span class="line">BenchmarkShopspringDecimalCase2<span class="number">-8</span>         <span class="number">300000</span>              <span class="number">5210</span> ns/op            <span class="number">4294</span> B/op        <span class="number">111</span> allocs/op</span><br><span class="line"></span><br><span class="line">BenchmarkTidbDecimalCase2<span class="number">-8</span>              <span class="number">3000000</span>               <span class="number">517</span> ns/op              <span class="number">83</span> B/op          <span class="number">3</span> allocs/op</span><br></pre></td></tr></table></figure><p>可见两种实现在上面两个case下表示准确, TiDB的decimal实现的性能高于shopspring的实现, 堆内存分配次数也更少.</p><p>##4. MyDecimal的已知问题</p><p>用了一段时间后, tidb.MyDecimal也有一些问题</p><ol><li>原版除法有bug, 可以通过除数和被除数同时放大一定倍数临时修复, 更好的解决方法需要官方人员解决, 已提issue, 这个bug真是匪夷所思. <a href="https://github.com/pingcap/tidb/issues/4873" target="_blank" rel="noopener">https://github.com/pingcap/tidb/issues/4873</a>, 2017.11.3官方修复decimal除法问题:<a href="https://github.com/pingcap/tidb/pull/4995/files" target="_blank" rel="noopener">https://github.com/pingcap/tidb/pull/4995/files</a>.</li><li>原版乘法有小问题, 行为不一致, 原版的from1和to不能为同一个指针, 但 Add Sub Div却可以. 可以通过copy参数修复.</li><li>移位小坑, 右移属于扩大数值, 没有问题. 左移有问题, 注意1左移两位不会变成0.01, 所以shift不要传负数.</li><li>round, 目前这个库的Round模式ModeHalfEven实际上是ModeHalfUp, 正常的四舍五入, 不是float的ModeHalfEven. 3.5=&gt;4, 4.5=&gt;5, 5.5=&gt;6, 注意后期是否有变更.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;##1 浮点数为什么不精确&lt;br&gt;先看两个case&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="decimal" scheme="https://imhanjm.com/tags/decimal/"/>
    
  </entry>
  
  <entry>
    <title>DockerContainer下gdb无法正常工作的解决办法</title>
    <link href="https://imhanjm.com/2017/08/20/DockerContainer%E4%B8%8Bgdb%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://imhanjm.com/2017/08/20/DockerContainer下gdb无法正常工作的解决办法/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-20T15:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天想在Mac上使用gdb调试一个Linux下编译的动态链接库, 以正常选项启动一个docker container, 运行gdb却发现如下错误提示.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">warning: Error disabling address space randomization: Operation not permitted</span><br><span class="line">Cannot create process: Operation not permitted</span><br><span class="line">During startup program exited with code 127.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>在google搜索结果里第6个才找到正确答案, <a href="https://www.google.com/search?safe=off&amp;q=docker+gdb+warning%3A+Error+disabling+address+space+randomization%3A+Operation+not+permitted+Cannot+create+process%3A+Operation+not+permitted+During+startup+program+exited+with+code+127&amp;oq=docker+gdb+warning%3A+Error+disabling+address+space+randomization%3A+Operation+not+permitted+Cannot+create+process%3A+Operation+not+permitted+During+startup+program+exited+with+code+127" target="_blank" rel="noopener">https://www.google.com/search?safe=off&amp;q=docker+gdb+warning%3A+Error+disabling+address+space+randomization%3A+Operation+not+permitted+Cannot+create+process%3A+Operation+not+permitted+During+startup+program+exited+with+code+127&amp;oq=docker+gdb+warning%3A+Error+disabling+address+space+randomization%3A+Operation+not+permitted+Cannot+create+process%3A+Operation+not+permitted+During+startup+program+exited+with+code+127</a>, 原来是docker run中的一个不太常用的选项, docker run –privileged, 加上即可.</p><p>于是找官方文档查看此选项的解释, 了解到: 默认docker是以受限模式下运行container, 如不能在container中运行再运行一个docker, 不能访问宿主机上的真实设备, /dev/, gdb无法访问真实的内存设备.</p><blockquote><p>Runtime privilege and Linux capabilities</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--cap-add: Add Linux capabilities</span><br><span class="line">--cap-drop: Drop Linux capabilities</span><br><span class="line">--privileged=false: Give extended privileges to this container</span><br><span class="line">--device=[]: Allows you to run devices inside the container without the --privileged flag.</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>By default, Docker containers are “unprivileged” and cannot, for example, run a Docker daemon inside a Docker container. This is because by default a container is not allowed to access any devices, but a “privileged” container is given access to all devices (see the documentation on cgroups devices).</p></blockquote><blockquote><p>When the operator executes docker run –privileged, Docker will enable access to all devices on the host as well as set some configuration in AppArmor or SELinux to allow the container nearly all the same access to the host as processes running outside containers on the host. Additional information about running with –privileged is available on the Docker Blog.</p></blockquote><blockquote><p>If you want to limit access to a specific device or devices you can use the –device flag. It allows you to specify one or more devices that will be accessible within the container.</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;$ docker run --device=/dev/snd:/dev/snd ...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;昨天想在Mac上使用gdb调试一个Linux下编译的动态链接库, 以正常选项启动一个docker container, 运行gdb却发现如下错误提示.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
        
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://imhanjm.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go sync.Pool Slice Benchmark</title>
    <link href="https://imhanjm.com/2017/07/02/Go%20sync.Pool%20slice%20benchmark/"/>
    <id>https://imhanjm.com/2017/07/02/Go sync.Pool slice benchmark/</id>
    <published>2017-07-01T16:00:00.000Z</published>
    <updated>2017-07-02T15:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>纠结于<code>[]struct</code>还是<code>[]*struct</code><br>直接<code>make([]struct,0)</code> 后append 还是 用<code>sync.Pool</code> <code>make([]struct,100)</code></p><p>写段代码跑个分, 结论是</p><ol><li><code>[]*struct</code>的要比<code>[]struct</code>多n次取指针的内存分配, 所有更慢, 如果不用修改结构体元素内的值, 没有必要用指针切片</li><li>append<code>[]*struct</code>要比<code>[]struct</code>慢</li><li><code>sync.Pool</code>效果明显</li></ol><p>benchmark结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BenchmarkStructSliceWithoutPool-8                 200000              5458 ns/op           16320 B/op          8 allocs/op</span><br><span class="line">BenchmarkStructPointerSliceWithoutPool-8          200000              6045 ns/op            8504 B/op        109 allocs/op</span><br><span class="line">BenchmarkStructSliceWithPool-8                   1000000              1287 ns/op              32 B/op          1 allocs/op</span><br><span class="line">BenchmarkStructPointerSliceWithPool-8             300000              4910 ns/op            6498 B/op        102 allocs/op</span><br></pre></td></tr></table></figure><p>benchmark代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> structSlicePool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]Basic, <span class="number">100</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> structPointerSlicePool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]*Basic, <span class="number">100</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Basic <span class="keyword">struct</span> &#123;</span><br><span class="line">Id, N1, N2, N3, N4, N5 <span class="keyword">int</span></span><br><span class="line">Name                   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStructSliceWithoutPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> list []Basic</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">101</span>; j++ &#123;</span><br><span class="line"><span class="keyword">var</span> data = Basic&#123;Id: j, Name: <span class="string">"Name"</span>&#125;</span><br><span class="line">list = <span class="built_in">append</span>(list, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStructPointerSliceWithoutPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> list []*Basic</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">101</span>; j++ &#123;</span><br><span class="line"><span class="keyword">var</span> data = Basic&#123;Id: j, Name: <span class="string">"Name"</span>&#125;</span><br><span class="line">list = <span class="built_in">append</span>(list, &amp;data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStructSliceWithPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">list := structSlicePool.Get().([]Basic)</span><br><span class="line">initLen := <span class="built_in">len</span>(list)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">101</span>; j++ &#123;</span><br><span class="line"><span class="keyword">var</span> data = Basic&#123;Id: j, Name: <span class="string">"Name"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> j &lt; initLen &#123;</span><br><span class="line">list[j] = data</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">structSlicePool.Put(list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkStructPointerSliceWithPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">list := structPointerSlicePool.Get().([]*Basic)</span><br><span class="line">initLen := <span class="built_in">len</span>(list)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">101</span>; j++ &#123;</span><br><span class="line"><span class="keyword">var</span> data = Basic&#123;Id: j, Name: <span class="string">"Name"</span>&#125;</span><br><span class="line"><span class="keyword">if</span> j &lt; initLen &#123;</span><br><span class="line">list[j] = &amp;data</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, &amp;data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">structPointerSlicePool.Put(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;纠结于&lt;code&gt;[]struct&lt;/code&gt;还是&lt;code&gt;[]*struct&lt;/code&gt;&lt;br&gt;直接&lt;code&gt;make([]struct,0)&lt;/code&gt; 后append 还是 用&lt;code&gt;sync.Pool&lt;/code&gt;
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="benchmark" scheme="https://imhanjm.com/tags/benchmark/"/>
    
  </entry>
  
  <entry>
    <title>Go最佳实践</title>
    <link href="https://imhanjm.com/2017/06/24/Go%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://imhanjm.com/2017/06/24/Go最佳实践/</id>
    <published>2017-06-23T16:00:00.000Z</published>
    <updated>2018-11-18T14:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来自NSQ"><a href="#来自NSQ" class="headerlink" title="来自NSQ"></a>来自NSQ</h2><p>nsq的官方文档的Dsign中提到一个PPT<a href="https://speakerdeck.com/snakes/nsq-nyc-golang-meetup" target="_blank" rel="noopener">https://speakerdeck.com/snakes/nsq-nyc-golang-meetup</a>, 里面有这样一段话<br><img src="https://ws1.sinaimg.cn/large/cfe1407cgy1fgwq34bdnzj213y0pihcj.jpg" alt><br>总结一下.</p><ol><li>don’t be afraid of <strong>sync</strong> package<br>sync包里有</li></ol><ul><li>sync.Mutex(互斥锁,一读一写)</li><li>sync.RWMutex(读写锁,可以多读一写)</li><li>sync.Pool(对象池, 合理利用可以减少内存分配, 降低GC压力, 稍后写一篇博客说说)</li><li>sync.Once(并发控制. 适用于开几个goroutines去执行一个只执行一次的任务, 比如单例模式)</li><li>sync.Cond(并发控制, cond.Wait()阻塞至其他goroutie运行到cond.Signal())</li><li>sync.WaitGroup(并发控制. 通常用法 wg.Add增加任务数量 goroutie完成任务后执行wg.Done,任务数量减1 wg.Wait等待wg任务数量为0)</li></ul><ol start="2"><li>goroutines are <strong>cheap</strong> not <strong>free</strong><br>这句话在其他地方也看过, <code>go func()</code>简单好用, 创建开销也很小, 但也是有开销的. 很多情况下开固定数量worker, 用channel传递数据, 效果会更好.<br>go-apns2中的example是个非常好的例子.<a href="https://github.com/sideshow/apns2/blob/master/_example/channel/main.go" target="_blank" rel="noopener">https://github.com/sideshow/apns2/blob/master/_example/channel/main.go</a></li></ol><p>注意一个问题, go里面一个goroutine panic了, 会导致进程退出, 所以<code>go func()</code>时第一行带上</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> err:=<span class="built_in">recover</span>(); err!=<span class="literal">nil</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>是安全的做法, worker channel法时类似</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(ch, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">ch &lt;- <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, goId <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"worker%d running"</span>, goId)</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"worker%d recover error:%s"</span>, goId, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">log.Printf(<span class="string">"worker%d received data:%d"</span>, goId, data)</span><br><span class="line"><span class="keyword">if</span> data == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">"worker%d panic"</span>, goId))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fasthttp之所以快, 其中一个原因就是net/http是来一个连接就创建一个goroutie, 而fasthttp用了池复用了goroutines.</p><ol start="3"><li><p>watch your allocations (string() is costly, re-user buffers)<br>go里面 []byte和string互转是会发生复制的, 开销明显, 如果代码里频繁互转, 考虑使用bytes.buffer 和 sync.Pool</p></li><li><p>use anonymous structs for arbitrary JSON<br>在写http api时, parse body这种事情, 如果只是纯粹取body里的json数据, 没必要单独定义结构体, 在函数里定义一个匿名结构体就好. <code>var s struct { A int}</code></p></li><li><p>no built-in per-request HTTP timeouts<br>这是说要注意默认的httpClient没有超时</p></li><li><p>synchronizing goroutine exit is hard - log each cleanup step in long-running goroutines<br>同步化的goroutine一不小心就没有退出, 如果你写一个长期运行的服务, 用logger记录每一个goroutine的清理退出, 防止goroutine泄露</p></li><li><p>select skips nil channels </p></li></ol><p>select语句是会跳过nil的channels的. 因为在Go里往已经close掉的channel里发送数据是会panic的, 可以利用select语句.<br>附: channel操作导致panic的情况有: 关闭一个nil的channel, 关闭一个已经关闭的channel( j,ok:= &lt;- ch, ok为false时代表ch已经关闭了), 往一个已经关闭的channel里发送数据(从已经关闭的channel里读数据是OK的, 如果这个channel是带缓冲的, 那么可以读到所有数据)</p><h2 id="来自GO箴言"><a href="#来自GO箴言" class="headerlink" title="来自GO箴言"></a>来自GO箴言</h2><p>Python有<code>import this</code>的zen of Python, 想不到Go也有箴言<br><a href="https://speakerdeck.com/ajstarks/go-proverbs" target="_blank" rel="noopener">https://speakerdeck.com/ajstarks/go-proverbs</a><br><img src="https://ws1.sinaimg.cn/large/cfe1407cgy1fh5dfxouv0j212o0lsdop.jpg" alt></p><ol><li>在go里, goroutines之间通信不要用共享内存的方式实现, 应该用channel来实现</li><li>并发不是并行</li><li>channel是编排, mutexs是串行</li><li>interface定义越多的方法, 抽象程度越低. Go提倡用接口组合的方式实现更大的接口</li><li>零值, 猜测这里说的是struct{}吧, struct{}是一个不占内存的空结构体, 在用map实现set, channel发送无额外意义的signal时能降低内存分配</li><li>提倡gofmt</li><li>一点点复制比一点点依赖好. 官方包里有时能见到一些复制的代码, 这是为了不互相依赖</li><li>syscall每个平台实现不一样, 要加build tags</li><li>cgo每个平台的lib不一样, 要加build tags</li><li>Cgo不是go</li><li>unsafe包不提供保障</li><li>简洁胜过高效</li><li>error是值  可以用值的方式去处理错误: 传递, 比较</li><li>不用仅检查错误, 要优雅地处理</li><li>多花精力设计架构, 模块命名, 写详细的文档</li><li>写良好的文档给用户</li><li>对于普通错误, 应该用多值返回错误, 而不是手动panic</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li>写可重复使用的函数, 接收接口类型, 返回具体类型</li><li>写可扩展便于二次包装的函数, 接收接口类型, 返回接口类型. 如标准库的database/sql包</li></ol><h2 id="传值还是传指针"><a href="#传值还是传指针" class="headerlink" title="传值还是传指针"></a>传值还是传指针</h2><ol><li>指针仅用于要修改值的场景和反射, 其他场景尽可能地用值传递, 能让变量尽可能分配在栈上, 减少GC压力, 提高性能. 还能减少nil 参考 <a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/" target="_blank" rel="noopener">https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/</a></li></ol><h2 id="Golang-Github"><a href="#Golang-Github" class="headerlink" title="Golang Github"></a>Golang Github</h2><p><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;来自NSQ&quot;&gt;&lt;a href=&quot;#来自NSQ&quot; class=&quot;headerlink&quot; title=&quot;来自NSQ&quot;&gt;&lt;/a&gt;来自NSQ&lt;/h2&gt;&lt;p&gt;nsq的官方文档的Dsign中提到一个PPT&lt;a
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>GO Logger 日志实践</title>
    <link href="https://imhanjm.com/2017/05/19/Go%20logger%20%E6%97%A5%E5%BF%97%E5%AE%9E%E8%B7%B5/"/>
    <id>https://imhanjm.com/2017/05/19/Go logger 日志实践/</id>
    <published>2017-05-18T16:00:00.000Z</published>
    <updated>2018-02-20T16:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析一下用过的打印日志的log包"><a href="#分析一下用过的打印日志的log包" class="headerlink" title="分析一下用过的打印日志的log包"></a>分析一下用过的打印日志的log包</h2><ol><li>Go标准库自带log, 这个log的func比较少, 没有区分level, 但足够简单, 有prefix功能, 可以设置flag来控制时间格式, caller的文件名和行数, 其它的标准包如 net/http database/sql 等也用了此包.</li><li>对自带的log进行包装, 加入level, 颜色. 如<a href="https://github.com/ngaut/log" target="_blank" rel="noopener">ngaut/log</a>, 这个log star数并不多, 还是从最近很火的一个项目<a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">pingcap/tidb</a>里看到的, 有点小清新的感觉, 但这个log可能只是为tidb使用的, 缺少自带log的一些方法, 导致没法使用在一些可以定制logger的第三方库如gorm中. 于是我fork了一下<a href="https://github.com/hanjm/log" target="_blank" rel="noopener">https://github.com/hanjm/log</a>, 增加了一些方法, 以便可以给gorm用.</li><li>完全自己实现的log, 结构化输出, 通常是key=value或json, 有名的有<a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">logrus</a>, <a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a>等. 第一次看到logrus感觉美极了, 于是大量使用, 直到在关注tidb的时候收到带日志的issues邮件, 里面的日志带了caller, 感觉很有用, 于是去搜logrus的issue看有没有这个功能, 搜到了一个issue<a href="https://github.com/sirupsen/logrus/issues/63" target="_blank" rel="noopener">https://github.com/sirupsen/logrus/issues/63</a>, 讨论了三年这个功能还没加上, 只好放弃美丽的logrus, 找到了替代品zap, zap的设计非常好, 定制性强. log是经常调用的代码, 每次调用不可避免地要进行内存分配, 分配次数和每次分配的内存大小将影响性能. 对log内容的处理也是一个涉及到性能的点, 像log.Printf参数是interface{}, logrus的field是map[stirng]interface{}, 打印interface{}只能靠reflect, Go是静态强类型语言, 用反射的开销相对比较大, 所以zap使用了手动指定类型的方式, 从zap提供的benchmark上开看, 性能提升还是蛮大的, 虽然相比logrus使用起来更麻烦, 但为了性能, 还是值得的.</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>为了方便进行日志分析, 统一用json行日志, 这样用elk时可以免去定制正则表达式存储到elasticSearch的field中.</li><li>net/http database/sql 及一些第三方包可能直接使用了标注库的log, 有个trick可以改变所有使用标准包log的行为, 通过<code>log.SetOutput(w io.Writer)</code>来改变位置, w是一个实现了<code>Write(p []byte) (n int, err error)</code>方法的io.Writer即可.</li><li>runtime.Caller可以得到调用者的pc, 文件名, 文件行数, runtime.FuncForPC(pc).Name()可以得到pc所在的函数名, 对于debug非常有帮助. 但有一定性能开销, 所以方案是: 对于http server的access log, 没有必要使用带caller的日志, 而对于http api具体实现的函数内的log, 有必要记录caller, 而且光有文件名和行数还不够, 毕竟改了代码行数就变了, 而函数名一般不会变, 带上函数名会更直观.</li><li>GitHub搜了一圈, 好多公司都会定制自己的log, 如tidb的<a href="https://github.com/ngaut/log" target="_blank" rel="noopener">ngaut/log</a>, 七牛的<a href="https://github.com/qiniu/log" target="_blank" rel="noopener">qiniu/log</a>, 饿了么的<a href="https://github.com/eleme/log" target="_blank" rel="noopener">eleme/log</a>, mailgun的<a href="https://github.com/mailgun/log" target="_blank" rel="noopener">mailgun/log</a>, 是的, 我也造一个小轮子<a href="https://github.com/hanjm/zaplog" target="_blank" rel="noopener">zaplog</a>.zaplog是包装了zap, 带caller func name, 兼容logrus stdlog 的日志输出工具.</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zaplog</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"go.uber.org/zap"</span></span><br><span class="line"><span class="string">"go.uber.org/zap/zapcore"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CallerEncoder will add caller to log. format is "filename:lineNum:funcName", e.g:"zaplog/zaplog_test.go:15:zaplog.TestNewLogger"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallerEncoder</span><span class="params">(caller zapcore.EntryCaller, enc zapcore.PrimitiveArrayEncoder)</span></span> &#123;</span><br><span class="line">enc.AppendString(strings.Join([]<span class="keyword">string</span>&#123;caller.TrimmedPath(), runtime.FuncForPC(caller.PC).Name()&#125;, <span class="string">":"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLoggerConfig</span><span class="params">(debugLevel <span class="keyword">bool</span>)</span> <span class="params">(loggerConfig zap.Config)</span></span> &#123;</span><br><span class="line">loggerConfig = zap.NewProductionConfig()</span><br><span class="line">loggerConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder</span><br><span class="line">loggerConfig.EncoderConfig.EncodeCaller = CallerEncoder</span><br><span class="line"><span class="keyword">if</span> debugLevel &#123;</span><br><span class="line">loggerConfig.Level = zap.NewAtomicLevelAt(zap.DebugLevel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCustomLoggers is a shortcut to get normal logger, noCallerLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCustomLoggers</span><span class="params">(debugLevel <span class="keyword">bool</span>)</span> <span class="params">(logger, noCallerLogger *zap.Logger)</span></span> &#123;</span><br><span class="line">loggerConfig := newLoggerConfig(debugLevel)</span><br><span class="line">logger, err := loggerConfig.Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">loggerConfig.DisableCaller = <span class="literal">true</span></span><br><span class="line">noCallerLogger, err = loggerConfig.Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLogger return a normal logger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">(debugLevel <span class="keyword">bool</span>)</span> <span class="params">(logger *zap.Logger)</span></span> &#123;</span><br><span class="line">loggerConfig := newLoggerConfig(debugLevel)</span><br><span class="line">logger, err := loggerConfig.Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNoCallerLogger return a no caller key value, will be faster</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNoCallerLogger</span><span class="params">(debugLevel <span class="keyword">bool</span>)</span> <span class="params">(noCallerLogger *zap.Logger)</span></span> &#123;</span><br><span class="line">loggerConfig := newLoggerConfig(debugLevel)</span><br><span class="line">loggerConfig.DisableCaller = <span class="literal">true</span></span><br><span class="line">noCallerLogger, err := loggerConfig.Build()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompatibleLogger is a logger which compatible to logrus/std log/prometheus.</span></span><br><span class="line"><span class="comment">// it implements Print() Println() Printf() Dbug() Debugln() Debugf() Info() Infoln() Infof() Warn() Warnln() Warnf()</span></span><br><span class="line"><span class="comment">// Error() Errorln() Errorf() Fatal() Fataln() Fatalf() Panic() Panicln() Panicf() With() WithField() WithFields()</span></span><br><span class="line"><span class="keyword">type</span> CompatibleLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">_log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCompatibleLogger return CompatibleLogger with caller field</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCompatibleLogger</span><span class="params">(debugLevel <span class="keyword">bool</span>)</span> *<span class="title">CompatibleLogger</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CompatibleLogger&#123;NewLogger(debugLevel).WithOptions(zap.AddCallerSkip(<span class="number">1</span>))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print logs a message at level Info on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Print</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Info(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Println logs a message at level Info on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Println</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Info(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Printf logs a message at level Info on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Info(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Debug logs a message at level Debug on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Debug</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Debug(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Debugln logs a message at level Debug on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Debugln</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Debug(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Debugf logs a message at level Debug on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Debugf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Debug(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Info logs a message at level Info on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Info</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Info(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Infoln logs a message at level Info on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Infoln</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Info(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Infof logs a message at level Info on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Infof</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Info(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warn logs a message at level Warn on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Warn</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Warn(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warnln logs a message at level Warn on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Warnln</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Warn(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Warnf logs a message at level Warn on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Warnf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Warn(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error logs a message at level Error on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Error(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errorln logs a message at level Error on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Errorln</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Error(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Errorf logs a message at level Error on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Error(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fatal logs a message at level Fatal on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Fatal(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fatalln logs a message at level Fatal on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Fatalln</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Fatal(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fatalf logs a message at level Fatal on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Fatal(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Panic logs a message at level Painc on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Panic</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Panic(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Panicln logs a message at level Painc on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Panicln</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Panic(fmt.Sprint(args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Panicf logs a message at level Painc on the compatibleLogger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l CompatibleLogger)</span> <span class="title">Panicf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">l._log.Panic(fmt.Sprintf(format, args...))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With return a logger with an extra field.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *CompatibleLogger)</span> <span class="title">With</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CompatibleLogger</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CompatibleLogger&#123;l._log.With(zap.Any(key, value))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithField return a logger with an extra field.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *CompatibleLogger)</span> <span class="title">WithField</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CompatibleLogger</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;CompatibleLogger&#123;l._log.With(zap.Any(key, value))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithFields return a logger with extra fields.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *CompatibleLogger)</span> <span class="title">WithFields</span><span class="params">(fields <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">CompatibleLogger</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> clog *CompatibleLogger</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> fields &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">clog = l.WithField(k, v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">clog = clog.WithField(k, v)</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> clog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FormatStdLog set the output of stand package log to zaplog</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatStdLog</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.Llongfile)</span><br><span class="line">log.SetOutput(&amp;logWriter&#123;NewNoCallerLogger(<span class="literal">false</span>)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> logWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write implement io.Writer, as std log's output</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w logWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">i := bytes.Index(p, []<span class="keyword">byte</span>(<span class="string">":"</span>)) + <span class="number">1</span></span><br><span class="line">j := bytes.Index(p[i:], []<span class="keyword">byte</span>(<span class="string">":"</span>)) + <span class="number">1</span> + i</span><br><span class="line">caller := bytes.TrimRight(p[:j], <span class="string">":"</span>)</span><br><span class="line"><span class="comment">// find last index of /</span></span><br><span class="line">i = bytes.LastIndex(caller, []<span class="keyword">byte</span>(<span class="string">"/"</span>))</span><br><span class="line"><span class="comment">// find penultimate index of /</span></span><br><span class="line">i = bytes.LastIndex(caller[:i], []<span class="keyword">byte</span>(<span class="string">"/"</span>))</span><br><span class="line">w.logger.Info(<span class="string">"stdLog"</span>, zap.ByteString(<span class="string">"caller"</span>, caller[i+<span class="number">1</span>:]), zap.ByteString(<span class="string">"log"</span>, bytes.TrimSpace(p[j:])))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;分析一下用过的打印日志的log包&quot;&gt;&lt;a href=&quot;#分析一下用过的打印日志的log包&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="log" scheme="https://imhanjm.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>MacOS下酷工具收集(持续)</title>
    <link href="https://imhanjm.com/2017/05/06/MacOS%E4%B8%8B%E9%85%B7%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86(%E6%8C%81%E7%BB%AD)/"/>
    <id>https://imhanjm.com/2017/05/06/MacOS下酷工具收集(持续)/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2018-12-15T13:10:54.336Z</updated>
    
    <content type="html"><![CDATA[<ol><li>LaunchRocket. 系统偏好设置中的用户与群组可以添加登录项脚本, 但对于需要root权限启动的应用无解, 脚本会卡在输入密码. LaunchRocket能优雅解决.(当然, 还有一种魔法方法: 用docker加<code>--restart always</code>的container或docker swarm service 跑, docker启动时会自动启动这些container/service) GitHub地址<a href="https://github.com/jimbojsb/launchrocket" target="_blank" rel="noopener">https://github.com/jimbojsb/launchrocket</a> <img src="https://raw.githubusercontent.com/jimbojsb/launchrocket/master/screenshots/LaunchRocket.png" alt="LaunchRocket"></li><li>Snip. Windows下有Winsnap、FastStone、Snipaste等此等优秀的截图软件, 相比之下, Mac上的截图软件要逊色不少. Winsnap有个很方便的特性是截图可以默认复制到剪切板, 很容易粘贴到其他软件去, Mac上snip也有这个特性, snip是一款腾讯开发的截图软件, 官网<a href="http://snip.qq.com/" target="_blank" rel="noopener">http://snip.qq.com/</a> </li><li>jietu. 还是腾讯开发的截图软件, 比snip更好用, 也是默认复制到剪切板, 而且提供编辑功能. 官网<a href="http://jietu.qq.com" target="_blank" rel="noopener">http://jietu.qq.com</a></li><li>Macdown. 好用优雅免费的Markdown书写工具. GitHub地址<a href="https://github.com/MacDownApp/macdown" target="_blank" rel="noopener">https://github.com/MacDownApp/macdown</a> 2018.12.15发现了更棒的Markdown软件Typora, 胜在颜值和文件夹模式.</li><li>Homebrew. yum/dnf之于centOS, apt之于Ubuntu, pacman之于ArchLinux, brew之于macOS, <code>brew install</code>简直不能太爽. 官网<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></li><li>Homebrew-Cask. <code>brew install</code>不能安装chrome Macdown这样的GUI app, Homebrew-Cask扩展了brew, GitHub地址<a href="https://github.com/caskroom/homebrew-cask" target="_blank" rel="noopener">https://github.com/caskroom/homebrew-cask</a> <img src="https://camo.githubusercontent.com/672f09c820c53a876e044e158cfd477791f4e249/68747470733a2f2f692e696d6775722e636f6d2f575961323535372e676966" alt="Homebrew-Cask"></li><li><p>privoxy. <code>brew pip npm install、docker pull</code>总是慢如蜗牛?  privoxy能将shadowsocks的socks代理(127.0.0.1:1080)转换为http/https代理, 有个奇特的地方是把它把文档写在配置文件的注释里, config文件有2271行, 初让人以为配置起来会巨复杂, 实际上基本的功能两行配置即可. <code>listen-address配置为0.0.0.0:8118</code>, 局域网内其他设备也可以走此代理<ip>:8118. 官网<a href="https://www.privoxy.org/" target="_blank" rel="noopener">https://www.privoxy.org/</a></ip></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listen-address  0.0.0.0:8118</span><br><span class="line">forward-socks5 / localhost:1080 .</span><br></pre></td></tr></table></figure><p> 然后在.zshrc或.bashrc中加入一下命令就可以通过<code>proxy</code> <code>dproxy</code>来切换是否在本终端下使用代理了.</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function proxy()&#123;</span><br><span class="line">    export http_proxy=http://127.0.0.1:8118</span><br><span class="line">    export https_proxy=https://127.0.0.1:8118</span><br><span class="line">    export HTTP_PROXY=http://127.0.0.1:8118</span><br><span class="line">    export HTTPS_PROXY=https://127.0.0.1:8118</span><br><span class="line">&#125;</span><br><span class="line">function dproxy()&#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset https_proxy</span><br><span class="line">    unset HTTP_PROXY</span><br><span class="line">    unset HTTPS_PROXY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>proxier 可以按进程名指定哪些进程走ss代理, 比如ssh</p></li><li>kcptun. bandwagon上的shadowsocks越来越慢, 不用kcptun加速没法正常使用, 只能不太厚道地超量发包了. GitHub地址<a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a></li><li>oh-my-zsh的z命令. 手动输入一个很长的路径名不停地tab很麻烦, 配置了oh-my-zsh的话可以启用z命令(<code>edit: ~/.zshrc line: plugins=(git python z tmux)</code>), <code>z 文件夹名</code> 就可以跳转到常用目录中最符合输入文件夹名的文件夹中, 非常方便, GitHub地址<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a></li><li>aria2. 非常厉害的下载器, <code>brew install aria2</code>即可. GitHub地址:<a href="https://github.com/aria2/aria2" target="_blank" rel="noopener">https://github.com/aria2/aria2</a> GUI Client:<a href="https://github.com/yangshun1029/aria2gui" target="_blank" rel="noopener">https://github.com/yangshun1029/aria2gui</a></li><li>BaiduExporter. 百度网盘文件导出到aria2下载, GitHub地址<a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">https://github.com/acgotaku/BaiduExporter</a></li><li>Chrome插件加白描述文件. 有时需要安装一些在商店下架了的扩展, 比如BaiduExporter, 在扩展页面安装后重启chrome会提示此扩展程序并非来自chrome商店,启用开关灰色无法启用, 可以下载此描述文件将特定扩展id加入白名单. <a href="https://hencolle.com/2016/10/16/baidu_exporter/" target="_blank" rel="noopener">https://hencolle.com/2016/10/16/baidu_exporter/</a></li><li>坚果云.同步配置文件,pdf书非常方便.</li><li>Monaco字体. 非常舒服的等宽代码字体 <a href="https://github.com/hanjm/codeFont" target="_blank" rel="noopener">https://github.com/hanjm/codeFont</a></li><li>Scroll Reverser. 外接鼠标神器, 让触摸板是自然方向, 鼠标是习惯的Windows滚动方向.</li><li>Karabiner-Elements. 外接键盘神器, 我就想禁用capsLock键, 让右边的option键变成control键, 能把外接键盘的Windows键映射为command键.</li><li>ssh tunnel. ssh隧道管理器, 本地连接远程服务器的kibana nsqAdmin mysql简直不要太爽</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;ol&gt;
&lt;li&gt;LaunchRocket. 系统偏好设置中的用户与群组可以添加登录项脚本, 但对于需要root权限启动的应用无解, 脚本会卡在输入密码. LaunchRocket能优雅解决.(当然, 还有一种魔法方法: 用docker加&lt;code&gt;--restart
        
      
    
    </summary>
    
    
      <category term="Cool tools" scheme="https://imhanjm.com/tags/Cool-tools/"/>
    
      <category term="Macos" scheme="https://imhanjm.com/tags/Macos/"/>
    
  </entry>
  
  <entry>
    <title>Linux Cli下酷工具收集(持续)</title>
    <link href="https://imhanjm.com/2017/05/06/Linux%20cli%E4%B8%8B%E9%85%B7%E5%B7%A5%E5%85%B7%E6%94%B6%E9%9B%86(%E6%8C%81%E7%BB%AD)/"/>
    <id>https://imhanjm.com/2017/05/06/Linux cli下酷工具收集(持续)/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2017-05-19T15:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>mycli. ipython之于Python, mycli之于mysql. 当然还有pgcli. Python写的工具. <img src="https://raw.githubusercontent.com/dbcli/mycli/master/screenshots/tables.png" alt="mycli"> Github地址:<a href="https://github.com/dbcli/mycli" target="_blank" rel="noopener">https://github.com/dbcli/mycli</a></li><li>youtube-dl. youtube下载器, 能直接下载youtube视频列表. Python写的工具. </li><li>oh-my-zsh的z命令. 手动输入一个很长的路径名不停地tab很麻烦, 配置了oh-my-zsh的话可以启用z命令(<code>edit: ~/.zshrc line: plugins=(git python z tmux)</code>), <code>z 文件夹名</code> 就可以跳转到常用目录中最符合输入文件夹名的文件夹中, 非常方便, GitHub地址<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a></li><li><p>privoxy. <code>brew pip npm install、docker pull</code>总是慢如蜗牛?  privoxy能将shadowsocks的socks代理(127.0.0.1:1080)转换为http/https代理, 有个奇特的地方是把它把文档写在配置文件的注释里, config文件有2271行, 初让人以为配置起来会巨复杂, 实际上基本的功能两行配置即可. <code>listen-address配置为0.0.0.0:8118</code>, 局域网内其他设备也可以走此代理<ip>:8118. 官网<a href="https://www.privoxy.org/" target="_blank" rel="noopener">https://www.privoxy.org/</a></ip></p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listen-address  0.0.0.0:8118</span><br><span class="line">forward-socks5 / localhost:1080 .</span><br></pre></td></tr></table></figure><p> 然后在.zshrc或.bashrc中加入一下命令就可以通过<code>proxy</code> <code>dproxy</code>来切换是否在本终端下使用代理了.</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function proxy()&#123;</span><br><span class="line">    export http_proxy=http://127.0.0.1:8118</span><br><span class="line">    export https_proxy=https://127.0.0.1:8118</span><br><span class="line">&#125;</span><br><span class="line">function dproxy()&#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset https_proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>kcptun. bandwagon上的shadowsocks越来越慢, 不用kcptun加速没法正常使用, 只能不太厚道地超量发包了. GitHub地址<a href="https://github.com/xtaci/kcptun" target="_blank" rel="noopener">https://github.com/xtaci/kcptun</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;ol&gt;
&lt;li&gt;mycli. ipython之于Python, mycli之于mysql. 当然还有pgcli. Python写的工具. &lt;img
        
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://imhanjm.com/tags/Linux/"/>
    
      <category term="Cool tools" scheme="https://imhanjm.com/tags/Cool-tools/"/>
    
  </entry>
  
  <entry>
    <title>知名公司架构资料整理(持续)</title>
    <link href="https://imhanjm.com/2017/05/04/%E7%9F%A5%E5%90%8D%E5%85%AC%E5%8F%B8%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0(%E6%8C%81%E7%BB%AD)/"/>
    <id>https://imhanjm.com/2017/05/04/知名公司后端架构学习(持续)/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2018-05-20T03:08:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-知乎"><a href="#1-知乎" class="headerlink" title="1.知乎"></a>1.知乎</h3><p>主要语言栈: Python Java<br>演讲:<br><a href="http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2014/12/zhihu-architecture-evolution</a></p><h3 id="2-饿了么"><a href="#2-饿了么" class="headerlink" title="2.饿了么"></a>2.饿了么</h3><p>主要语言栈: Python Java Go<br>演讲:</p><ol><li>2017 gopher上海meetup<br>开源项目:</li><li>Python: thrift-py RPC轮子</li></ol><h3 id="3-Bilibili"><a href="#3-Bilibili" class="headerlink" title="3.Bilibili"></a>3.Bilibili</h3><p>开源项目:</p><ol><li>goim</li></ol><h3 id="4-Teambition"><a href="#4-Teambition" class="headerlink" title="4. Teambition"></a>4. Teambition</h3><p>主要语言栈: node.js Go</p><p>演讲:</p><ol><li>2017 gopher上海meetup</li></ol><p>开源项目:</p><ol><li>Go: Gear HTTP框架</li></ol><h3 id="5-Klook"><a href="#5-Klook" class="headerlink" title="5. Klook"></a>5. Klook</h3><p>主要语言栈: Go</p><h3 id="6-PingCAP"><a href="#6-PingCAP" class="headerlink" title="6. PingCAP"></a>6. PingCAP</h3><p>主要语言栈: GO</p><p>开源项目:</p><ol><li>Go: TiDB 数据库</li><li>Go: log 日志工具</li></ol><p><a href="https://github.com/davideuler/architecture.of.internet-product" target="_blank" rel="noopener">https://github.com/davideuler/architecture.of.internet-product</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;1-知乎&quot;&gt;&lt;a href=&quot;#1-知乎&quot; class=&quot;headerlink&quot; title=&quot;1.知乎&quot;&gt;&lt;/a&gt;1.知乎&lt;/h3&gt;&lt;p&gt;主要语言栈: Python Java&lt;br&gt;演讲:&lt;br&gt;&lt;a
        
      
    
    </summary>
    
    
      <category term="架构" scheme="https://imhanjm.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 连接池问题</title>
    <link href="https://imhanjm.com/2017/04/26/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%97%AE%E9%A2%98/"/>
    <id>https://imhanjm.com/2017/04/26/mysql连接池问题/</id>
    <published>2017-04-25T16:00:00.000Z</published>
    <updated>2017-05-06T05:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近应用日志里发现了mysql偶尔会出现问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56346-&gt;127.0.0.1:3306: write: broken pipe</span><br><span class="line">[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56346-&gt;127.0.0.1:3306: write: broken pipe</span><br><span class="line">[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56350-&gt;127.0.0.1:3306: write: broken pipe</span><br><span class="line">[mysql] 2017/04/26 10:01:05 packets.go:130: write tcp 127.0.0.1:56350-&gt;127.0.0.1:3306: write: broken pipe</span><br></pre></td></tr></table></figure><p>找GitHub issues, 提到了和mysql的wait_timeout变量有关系, <a href="https://github.com/go-sql-driver/mysql/issues/446" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql/issues/446</a>, 于是找MySQL文档<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#idm140549060476496" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#idm140549060476496</a>.</p><p>相关说明如下:<br>The number of seconds the server waits for activity on a noninteractive connection before closing it.<br>On thread startup, the session wait_timeout value is initialized from the global wait_timeout value or from the global interactive_timeout value, depending on the type of client (as defined by the CLIENT_INTERACTIVE connect option to mysql_real_connect()). See also interactive_timeout.</p><p>默认是28800s, 8小时.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%wait_timeout%&apos;;                                                                                                                                                                                                                      </span><br><span class="line">+--------------------------+----------+</span><br><span class="line">| Variable_name            | Value    |</span><br><span class="line">+--------------------------+----------+</span><br><span class="line">| innodb_lock_wait_timeout | 50       |</span><br><span class="line">| lock_wait_timeout        | 31536000 |</span><br><span class="line">| wait_timeout             | 28800    |</span><br><span class="line">+--------------------------+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>解决办法:<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.SetConnMaxLifetime(time.Hour*<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近应用日志里发现了mysql偶尔会出现问题&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[mysql] 2017/04/26
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
      <category term="mysql" scheme="https://imhanjm.com/tags/mysql/"/>
    
      <category term="连接池" scheme="https://imhanjm.com/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Go strings.TrimLeft() strings.TrimPrefix().md</title>
    <link href="https://imhanjm.com/2017/04/24/Go-strings.TrimLeft-strings.TrimPrefix/"/>
    <id>https://imhanjm.com/2017/04/24/Go-strings.TrimLeft-strings.TrimPrefix/</id>
    <published>2017-04-23T16:00:00.000Z</published>
    <updated>2017-05-06T15:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在调试时, 有个函数的返回的结果很奇怪, 和预期的输入差了一个字符, 而review代码时却没发现什么问题, 后面各种加<code>logger.Debugf()</code>才发现是<code>strings.TrimLeft()</code>这个函数表现得和自己的预期不一致, 从函数名上看这个是删除字符串左边的字符串, 但是传入一个带<code>:</code>的字符串去调用,发现:后面的字符也被Trim了, 于是去Github issues上搜了下这个问题<a href="https://github.com/golang/go/issues/19371" target="_blank" rel="noopener">https://github.com/golang/go/issues/19371</a>, 有人也感觉奇怪也反馈过, 解释是 <code>The second argument to Trim is a set of code points, not a prefix/suffix.</code> , 于是去翻了下文档, 确实是这样的.</p><p><code>TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.</code></p><p>问题复现代码(<code>go 1.8</code>) <a href="https://play.golang.org/p/YtmVQIf2_i" target="_blank" rel="noopener">https://play.golang.org/p/YtmVQIf2_i</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"friends:d15fc7bb-1e67-11e7-b8a5-00163e008796"</span></span><br><span class="line">prefix1 := <span class="string">"friends:"</span></span><br><span class="line">prefix2 := <span class="string">"friends"</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, strings.TrimLeft(str, prefix1))</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, strings.TrimPrefix(str, prefix1))</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, strings.TrimLeft(str, prefix2))</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, strings.TrimPrefix(str, prefix2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15fc7bb-1e67-11e7-b8a5-00163e008796</span><br><span class="line">d15fc7bb-1e67-11e7-b8a5-00163e008796</span><br><span class="line">:d15fc7bb-1e67-11e7-b8a5-00163e008796</span><br><span class="line">:d15fc7bb-1e67-11e7-b8a5-00163e008796</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;今天在调试时, 有个函数的返回的结果很奇怪, 和预期的输入差了一个字符, 而review代码时却没发现什么问题,
        
      
    
    </summary>
    
    
      <category term="Go" scheme="https://imhanjm.com/tags/Go/"/>
    
  </entry>
  
</feed>
